{"version":3,"sources":["../src/runtime/Store.ts","../src/runtime/Runtime.ts","../src/compiler/OutputBuffer.ts","../src/compiler/OutputRenderer.ts","../src/compiler/Compiler.ts","../src/grammar.ts","../src/lexer/Lexer.ts","../src/parser/Node.ts","../src/nodes/primitives/ColorPrimitiveNode.ts","../src/nodes/primitives/StringPrimitiveNode.ts","../src/nodes/primitives/VariablePrimitiveNode.ts","../src/nodes/OperatorNode.ts","../src/nodes/primitives/NumberPrimitiveNode.ts","../src/nodes/ExpressionNode.ts","../src/compiler/helpers/compile-expression-into-value.ts","../src/nodes/DefNode.ts","../src/nodes/StylePropertyNode.ts","../src/parser/helpers/parse-class.ts","../src/nodes/StyleNode.ts","../src/nodes/IncludeNode.ts","../src/nodes/ArrowNode.ts","../src/nodes/ImgNode.ts","../src/parser/helpers/compile-style-attrs.ts","../src/nodes/LineNode.ts","../src/nodes/TxtNode.ts","../src/nodes/RawNode.ts","../src/compiler/helpers/compile-with-vgap.ts","../src/nodes/GroupNode.ts","../src/nodes/ColNode.ts","../src/nodes/ColsNode.ts","../src/nodes/SpaceNode.ts","../src/nodes/BtnNode.ts","../src/parser/helpers/parse-body.ts","../src/nodes/FontNode.ts","../src/parser/helpers/parse-head.ts","../src/events/Manager.ts","../src/nodes/ArgumentNode.ts","../src/nodes/ArgumentListNode.ts","../src/nodes/BodyNode.ts","../src/parser/AstNode.ts","../src/errors/UnexpectedToken.ts","../src/parser/Parser.ts","../src/Elos.ts"],"sourcesContent":["export default class Store<T> {\n\n\t/**\n\t * @private\n\t */\n\tprivate items: Record<string, T> = {};\n\n\t/**\n\t * @param items\n\t */\n\tconstructor(items: Record<string, T> = {}) {\n\t\tthis.items = items;\n\t}\n\n\t/**\n\t * Sets a value by name\n\t * @param name\n\t * @param value\n\t */\n\tpublic set(name: string, value: T): T {\n\t\tthis.items[name] = value;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Gets a value by name\n\t * @param name\n\t */\n\tpublic get(name: string): T | null {\n\t\treturn this.items[name] || null;\n\t}\n\n\t/**\n\t * Gets all items as an object\n\t */\n\tpublic getAll(): Record<string, T> {\n\t\treturn this.items;\n\t}\n\n\t/**\n\t * Extends the items by an object of other items\n\t * @param items\n\t */\n\tpublic extend(items: Record<string, T>) {\n\t\tObject.assign(this.items, items);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic clear(): void {\n\t\tthis.items = {};\n\t}\n}","import {AttributeValue} from \"../types/attribute\";\nimport Store from \"./Store\";\n\nexport default class Runtime {\n\n\tprivate internal = new Store<any>({\n\t\tpath: '',\n\t\tcolsId: 0,\n\t\timgId: 0,\n\t\tclasses: {},\n\t\tidentStyles: {}\n\t});\n\n\tprivate globalVariables = new Store<AttributeValue>({\n\t\tpreview: '',\n\t\tedge: 35,\n\t\thgap: 10,\n\t\tvgap: 10,\n\t\tbgcolor: '#ffffff',\n\t\twidth: 650\n\t});\n\n\tprivate localVariables = new Store<AttributeValue>({});\n\n\t/**\n\t * @param name\n\t * @param value\n\t */\n\tpublic setLocalVariable(name: string, value: AttributeValue) {\n\t\treturn this.localVariables.set(name, value);\n\t}\n\n\t/**\n\t * @param name\n\t */\n\tpublic getLocalVariable(name: string): AttributeValue {\n\t\treturn this.localVariables.get(name);\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic getLocalVariables(): Store<AttributeValue> {\n\t\treturn this.localVariables;\n\t}\n\n\t/**\n\t *\n\t */\n\tpublic flushLocalVariables() {\n\t\tthis.localVariables.clear();\n\t}\n\n\t/**\n\t * @param name\n\t * @param value\n\t */\n\tpublic setVariable(name: string, value: AttributeValue) {\n\t\treturn this.globalVariables.set(name, value);\n\t}\n\n\tpublic getVariable(name: string): AttributeValue {\n\t\treturn this.globalVariables.get(name);\n\t}\n\n\tpublic getVariables(): Store<AttributeValue> {\n\t\treturn this.globalVariables;\n\t}\n\n\tpublic setInternalMemoryItem(name: string, value: any): any {\n\t\treturn this.internal.set(name, value);\n\t}\n\n\tpublic getInternalMemoryItem(name: string): any {\n\t\treturn this.internal.get(name);\n\t}\n\n\tpublic getInternalMemory(): Store<any> {\n\t\treturn this.internal;\n\t}\n\n\tpublic clone(): Runtime {\n\t\tconst runtime = new Runtime();\n\t\truntime.import(this);\n\t\treturn runtime;\n\t}\n\n\tpublic import(runtime: Runtime) {\n\t\tthis.internal.extend(runtime.getInternalMemory().getAll());\n\t\tthis.globalVariables.extend(runtime.getVariables().getAll());\n\t\tthis.localVariables.extend(runtime.getLocalVariables().getAll());\n\t}\n}","export default class OutputBuffer {\n\n\t/**\n\t *\n\t * @private\n\t */\n\tprivate head: string[] = [];\n\n\t/**\n\t *\n\t * @private\n\t */\n\tprivate body: string[] = [];\n\n\t/**\n\t *\n\t * @private\n\t */\n\tprivate foot: string[] = [];\n\n\t/**\n\t *\n\t * @param string\n\t */\n\twriteBody(string: string) {\n\t\tthis.body.push(string);\n\t}\n\n\t/**\n\t *\n\t * @param string\n\t */\n\twriteHead(string: string) {\n\t\tthis.head.push(string);\n\t}\n\n\t/**\n\t *\n\t * @param string\n\t */\n\twriteFoot(string: string) {\n\t\tthis.foot.push(string);\n\t}\n\n\t/**\n\t *\n\t */\n\tgetHead(): string {\n\t\treturn this.head.join('');\n\t}\n\n\t/**\n\t *\n\t */\n\tgetBody(): string {\n\t\treturn this.body.join('');\n\t}\n\n\t/**\n\t *\n\t */\n\tgetFoot(): string {\n\t\treturn this.foot.join('');\n\t}\n}\n","import OutputBuffer from \"./OutputBuffer\";\nimport Store from \"../runtime/Store\";\nimport {AttributeValue} from \"../types/attribute\";\n\nexport default class OutputRenderer {\n\n\trender(buffer: OutputBuffer, variables: Store<AttributeValue>) {\n\t\treturn `<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n\t<head>\n\t\t<!--[if !mso]><!-->\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t\t<!--<![endif]-->\n\t\t<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t\t<style type=\"text/css\">\n\t\t\t  * { padding: 0; margin: 0; }\n\t\t\t  #outlook a { padding:0; }\n\t\t\t  body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }\n\t\t\t  table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }\n\t\t\t  img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }\n\t\t\t  p { display:block;margin:13px 0; }\n\t\t\t</style>\n\t\t${buffer.getHead()}\n\t</head>\n\t<body bgcolor=\"${variables.get('bgcolor')}\">\n\t\t${buffer.getBody()}\n\t</body>\n</html>\n        `;\n\t}\n}\n","import {AttributeValue} from \"../types/attribute\";\nimport Node from \"../parser/Node\";\nimport Runtime from \"../runtime/Runtime\";\nimport OutputBuffer from \"./OutputBuffer\";\nimport OutputRenderer from \"./OutputRenderer\";\n\nexport default class Compiler {\n\n    /**\n     *\n     * @private\n     */\n    private readonly runtime: Runtime;\n\n    /**\n     * @private\n     */\n    private readonly buffer: OutputBuffer;\n\n    /**\n     * @private\n     */\n    private renderer: OutputRenderer;\n\n    /**\n     * @param runtime\n     */\n    constructor(runtime: Runtime = null) {\n        this.runtime = runtime ? runtime : new Runtime();\n        this.buffer = new OutputBuffer();\n        this.renderer = new OutputRenderer();\n    }\n\n    /**\n     *\n     */\n    clone(): Compiler {\n        return new Compiler(this.runtime.clone());\n    }\n\n    /**\n     *\n     * @param compiler\n     */\n    import(compiler: Compiler) {\n        this.runtime.import(compiler.getRuntime());\n    }\n\n    /**\n     *\n     */\n    getRuntime(): Runtime {\n        return this.runtime;\n    }\n\n    /**\n     *\n     * @param string\n     */\n    write(string: string) {\n        this.buffer.writeBody(string);\n    }\n\n    writeHead(string: string) {\n        this.buffer.writeHead(string);\n    }\n\n    writeLineToBody(string: string) {\n        this.buffer.writeBody('\\n'+string);\n    }\n\n    writeLineToHead(string: string) {\n        this.buffer.writeHead('\\n'+string);\n    }\n\n    /**\n     * @param name\n     * @param value\n     */\n    defineLocal(name: string, value: AttributeValue): AttributeValue {\n        this.runtime.setLocalVariable(name, value);\n        return value;\n    }\n\n    /**\n     *\n     */\n    flushLocalVariables() {\n        this.runtime.flushLocalVariables();\n    }\n\n    /**\n     * @param name\n     * @param value\n     */\n    define(name: string, value: AttributeValue): AttributeValue {\n        this.runtime.setVariable(name, value);\n        return value;\n    }\n\n    variable(name: string): AttributeValue {\n        if (this.runtime.getLocalVariable(name)) {\n            return this.runtime.getLocalVariable(name);\n        }\n\n        return this.runtime.getVariable(name);\n    }\n\n    remember(name: string, value: AttributeValue) {\n        return this.runtime.setInternalMemoryItem(name, value);\n    }\n\n    get(name: string): AttributeValue {\n        return this.runtime.getInternalMemoryItem(name);\n    }\n\n    getHead(): string {\n        return this.buffer.getHead();\n    }\n\n    getBody(): string {\n        return this.buffer.getBody();\n    }\n\n    compile(ast: Node) {\n        ast.compile(this);\n        return this.renderer.render(this.buffer, this.runtime.getVariables());\n    }\n}\n","export default {\n\n    REGEX_IDENT: /[a-zA-ZÆÐƎƏƐƔĲŊŒẞÞǷȜæðǝəɛɣĳŋœĸſßþƿȝĄƁÇĐƊĘĦĮƘŁØƠŞȘŢȚŦŲƯY̨Ƴąɓçđɗęħįƙłøơşșţțŧųưy̨ƴÁÀÂÄǍĂĀÃÅǺĄÆǼǢƁĆĊĈČÇĎḌĐƊÐÉÈĖÊËĚĔĒĘẸƎƏƐĠĜǦĞĢƔáàâäǎăāãåǻąæǽǣɓćċĉčçďḍđɗðéèėêëěĕēęẹǝəɛġĝǧğģɣĤḤĦIÍÌİÎÏǏĬĪĨĮỊĲĴĶƘĹĻŁĽĿʼNŃN̈ŇÑŅŊÓÒÔÖǑŎŌÕŐỌØǾƠŒĥḥħıíìiîïǐĭīĩįịĳĵķƙĸĺļłľŀŉńn̈ňñņŋóòôöǒŏōõőọøǿơœŔŘŖŚŜŠŞȘṢẞŤŢṬŦÞÚÙÛÜǓŬŪŨŰŮŲỤƯẂẀŴẄǷÝỲŶŸȲỸƳŹŻŽẒŕřŗſśŝšşșṣßťţṭŧþúùûüǔŭūũűůųụưẃẁŵẅƿýỳŷÿȳỹƴźżžẓ]/,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n\n    REGEX_VAR: /[a-zA-Z_-]/,\n    REGEX_VAR_START: /\\$/,\n\n    REGEX_COLOR: /[0-9a-fA-F]/,\n    REGEX_COLOR_START: /\\#/,\n\n    COMMENT_SYMBOL: '/',\n\n    BLOCK_OPEN_SYMBOL: '{',\n    BLOCK_CLOSE_SYMBOL: '}',\n\n    ARG_LIST_OPEN_SYMBOL: '(',\n    ARG_LIST_CLOSE_SYMBOL: ')',\n\n    STRING_ESCAPE_SYMBOL: '\\\\',\n\n    INCLUDE_NODE_KEYWORD: 'include',\n};\n","import grammar from \"../grammar\";\nimport {LexMode} from \"../types/lex-mode\";\nimport {TokenStream} from \"../types/token-stream\";\nimport {TokenType} from \"../types/token-type\";\n\nexport default class Lexer {\n\n    /**\n     * The source code to tokenize4\n     * @private\n     */\n    private source: string;\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || null;\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.STRING:\n                    this.lexString();\n                    break;\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.VAR:\n                    this.lexVariable();\n                    break;\n                case LexMode.COLOR:\n                    this.lexColor();\n                    break;\n                case LexMode.COMMENT:\n                    this.lexComment();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (\n            this.character === grammar.COMMENT_SYMBOL &&\n            this.nextCharacter === grammar.COMMENT_SYMBOL\n        ) {\n            return LexMode.COMMENT;\n        }\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_COLOR_START.exec(this.character)) {\n            return LexMode.COLOR;\n        }\n\n        if (grammar.REGEX_VAR_START.exec(this.character)) {\n            return LexMode.VAR;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    /**\n     * Tokenize identifier\n     * @private\n     */\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize string\n     * @private\n     */\n    private lexString() {\n\n        let escSequence = (this.character === grammar.STRING_ESCAPE_SYMBOL);\n\n        // String escaping\n        if (escSequence) {\n            this.cursor += 1;\n            // We directly alter the character and nextCharacter,\n            // so we can directly consume them further down in the method\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor + 1] || null;\n        }\n\n        if (this.character !== this.delimiter || escSequence) {\n            // Consume the character\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (this.nextCharacter === this.delimiter) {\n            this.tokens.push({\n                type: TokenType.STRING,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(true),\n            });\n            this.cursor++;\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n            this.delimiter = '';\n        }\n    }\n\n    /**\n     * Tokenize number\n     * @private\n     */\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    /**\n     * Tokenize symbol\n     * @private\n     */\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize newline\n     * @private\n     */\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize whitespace\n     * @private\n     */\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize color\n     * @private\n     */\n    private lexColor() {\n        if (grammar.REGEX_COLOR.exec(this.character)) {\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (!this.nextCharacter || this.value.length === 6 || !grammar.REGEX_COLOR.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.COLOR,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.mode = LexMode.ALL;\n            this.column += this.cursor - this.modeStartCursor;\n            this.delimiter = '';\n        }\n    }\n\n    /**\n     * Tokenize variable\n     * @private\n     */\n    private lexVariable() {\n        if (grammar.REGEX_VAR.exec(this.character)) {\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_VAR.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.VAR,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.mode = LexMode.ALL;\n            this.column += this.cursor - this.modeStartCursor;\n            this.delimiter = '';\n        }\n    }\n\n    /**\n     * Tokenize unknown\n     * @private\n     */\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    /**\n     * Tokenize comment\n     * @private\n     */\n    private lexComment() {\n        this.cursor++;\n\n        if (grammar.REGEX_NEWLINE.exec(this.nextCharacter)) {\n            this.mode = LexMode.ALL;\n            this.column++;\n        }\n    }\n}\n","import {Nullable} from \"../types/nullable\";\nimport {AttributeValue} from \"../types/attribute\";\nimport Parser from \"./Parser\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"../nodes/ExpressionNode\";\n\nexport default class Node {\n\n    /**\n     *\n     * @protected\n     */\n    protected value: string;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: string = '') {\n        this.value = value;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Node {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): string {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param parser\n     */\n    parse(parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param compiler\n     */\n    compile(compiler: Compiler) {\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeName = node.getName();\n            const nodeValue = node.getValue();\n\n            let attributes = node.getAttributes();\n            let attributesString = [];\n            for (let attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${attrNodeValue})` : ''}`;\n                }\n                attributesString.push(`${attribute}=${attrValue}`);\n            }\n\n            let tabs = indentAmount > 0 ? \"   \".repeat(indentAmount - 1) + \"└──\" : \"\";\n            let output = [`${tabs}${nodeName}${nodeValue ? `(${nodeValue})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join(\"\\n\");\n        };\n\n        return printNode(this);\n    }\n}\n","import Node from \"../../parser/Node\";\nimport Parser from \"../../parser/Parser\";\nimport {TokenType} from \"../../types/token-type\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class ColorPrimitiveNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.COLOR)) {\n            parser.insert(new ColorPrimitiveNode(parser.getCurrentValue()));\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        compiler.write(`#${this.getValue()}`);\n    }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class StringPrimitiveNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.STRING)) {\n            parser.insert(new StringPrimitiveNode(parser.getCurrentValue()));\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        compiler.write(this.value);\n    }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class VariablePrimitiveNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\n\t\tif (parser.accept(TokenType.VAR)) {\n\t\t\tparser.insert(new VariablePrimitiveNode(parser.getCurrentValue()));\n\t\t\tparser.advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcompile(compiler: Compiler) {\n\t\tcompiler.write(compiler.variable(this.value) as string);\n\t}\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class OperatorNode extends Node {\n\n  static parse(parser: Parser): boolean {\n    if (parser.skipWithValue(TokenType.SYMBOL, '+')) {\n      parser.insert(new OperatorNode('+'));\n      return true;\n    }\n\n    return false;\n  }\n\n  compile(compiler: Compiler) {\n    //\n  }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class NumberPrimitiveNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\n\t\tif (parser.accept(TokenType.NUMBER)) {\n\t\t\tparser.insert(new NumberPrimitiveNode(parser.getCurrentValue()));\n\t\t\tparser.advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcompile(compiler: Compiler) {\n\t\tcompiler.write(this.value);\n\t}\n}\n","import Node from \"../parser/Node\";\nimport ColorPrimitiveNode from \"./primitives/ColorPrimitiveNode\";\nimport StringPrimitiveNode from \"./primitives/StringPrimitiveNode\";\nimport Parser from \"../parser/Parser\";\nimport Compiler from \"../compiler/Compiler\";\nimport VariablePrimitiveNode from \"./primitives/VariablePrimitiveNode\";\nimport OperatorNode from \"./OperatorNode\";\nimport NumberPrimitiveNode from \"./primitives/NumberPrimitiveNode\";\n\nexport default class ExpressionNode extends Node {\n\n    static parse(parser: Parser): boolean {\n        if (\n            NumberPrimitiveNode.parse(parser) ||\n            VariablePrimitiveNode.parse(parser) ||\n            ColorPrimitiveNode.parse(parser) ||\n            StringPrimitiveNode.parse(parser)\n        ) {\n            // If we're not in an ExpressionNode yet, wrap it into one\n            if (parser.getScope().getName() !== this.name) {\n                parser.wrap(new ExpressionNode());\n            }\n\n            if (OperatorNode.parse(parser)) {\n                if (! this.parse(parser)) {\n                    throw new Error('Unexpected token '+parser.getCurrentToken().type);\n                }\n            } else {\n                // Get out of the expression\n                parser.traverseDown();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach((child, i) => {\n            child.compile(compiler);\n        });\n    }\n}\n","import Compiler from \"../Compiler\";\nimport ExpressionNode from \"../../nodes/ExpressionNode\";\nimport {Nullable} from \"../../types/nullable\";\n\nexport default {\n\tcompileExpressionIntoValue(compiler: Compiler, expression: Nullable<ExpressionNode>): Nullable<string> {\n\n\t\tif (! expression) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst compilerClone = compiler.clone();\n\t\texpression.compile(compilerClone);\n\t\treturn compilerClone.getBody();\n\t}\n};\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class DefNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'def')) {\n            parser.advance();\n\n            const defNode = new DefNode();\n\n            parser.insert(defNode);\n            parser.traverseUp();\n\n            if (parser.expect(TokenType.VAR)) {\n                defNode.setValue(parser.getCurrentValue());\n                parser.advance();\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('value');\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    public getVariableName(): string {\n        return this.getValue();\n    }\n\n    compile(compiler: Compiler) {\n        const value = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('value') as ExpressionNode);\n\n        compiler.define(this.getVariableName(), value);\n    }\n}\n","import Node from \"../parser/Node\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport StyleNode from \"./StyleNode\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class StylePropertyNode extends Node {\n\n    private property: string;\n\n    constructor(property: string, value: string) {\n        super(value);\n        this.property = property;\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.IDENT)) {\n\n            let property = parser.getCurrentValue();\n            parser.advance();\n\n            if (parser.accept(TokenType.NUMBER) || parser.accept(TokenType.STRING)) {\n                let value = parser.getCurrentValue();\n                parser.advance();\n                parser.insert(new StylePropertyNode(property, value));\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const parent = this.getParent() as StyleNode;\n        const name = parent.getValue();\n        const style = (parent.isClass ? compiler.get('classes') : compiler.get('identStyles'));\n\n        if (! style[name]) {\n            style[name] = [];\n        }\n\n        style[name] = [...style[name], [this.property, this.getValue()]];\n    }\n}\n","import {TokenType} from \"../../types/token-type\";\nimport Parser from \"../Parser\";\nimport {Nullable} from \"../../types/nullable\";\n\nexport default function parseClass(parser: Parser): Nullable<string> {\n\n    if (parser.skipWithValue(TokenType.SYMBOL, '.')) {\n        parser.expect(TokenType.IDENT);\n        let className = parser.getCurrentValue();\n        parser.advance();\n        return className;\n    }\n\n    return null;\n}\n","import Node from \"../parser/Node\";\nimport StylePropertyNode from \"./StylePropertyNode\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class StyleNode extends Node {\n\n    public isClass: boolean;\n\n    constructor(name: string, isClass: boolean) {\n        super(name);\n        this.isClass = isClass;\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'style')) {\n\n            let identifier = '';\n\n            if (parser.expect(TokenType.IDENT)) {\n                identifier = parser.getCurrentValue();\n                parser.advance();\n            }\n\n            let className = parseClass(parser);\n            let isClass = (className !== null);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new StyleNode(className ? className : identifier, isClass));\n                parser.in();\n            }\n\n            while (StylePropertyNode.parse(parser));\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                parser.out();\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => child.compile(compiler));\n    }\n}\n","import * as fs from \"node:fs\";\nimport Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport parseHead from \"../parser/helpers/parse-head\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport AstNode from \"../parser/AstNode\";\nimport {Manager} from \"../events/Manager\";\nimport {EventId} from \"../types/event-id\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport Lexer from \"../lexer/Lexer\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\nimport ArgumentListNode from \"./ArgumentListNode\";\nimport ArgumentNode from \"./ArgumentNode\";\nimport grammar from \"../grammar\";\n\nexport default class IncludeNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, grammar.INCLUDE_NODE_KEYWORD)) {\n            parser.advance();\n            parser.insert(new IncludeNode());\n            parser.traverseUp();\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('fileName');\n\n            if (ArgumentListNode.parse(parser)) {\n                parser.setAttribute('argumentList');\n            }\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const argumentListNode = this.getAttribute('argumentList');\n        let argumentNodes: ArgumentNode[] = [];\n\n        if (argumentListNode instanceof ArgumentListNode) {\n            argumentNodes = argumentListNode.getChildren() as ArgumentNode[];\n        }\n\n        // Compile fileName expression\n        const file = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('fileName') as ExpressionNode);\n\n        const path = compiler.get('path');\n        const filename = `${path}/${file}.elos`;\n        const code = fs.readFileSync(filename, 'utf8');\n\n        // Emit FILE_TOUCH event\n        Manager.emit(EventId.FILE_TOUCH, {\n            filename,\n        });\n\n        // Lex\n        const tokens = (new Lexer()).tokenize(code);\n\n        // Parse\n        const parser = new Parser();\n        parser.setTokenStream(tokens);\n\n        parseHead(parser);\n        parseBody(parser);\n\n        const ast = parser.getAst();\n        ast.setParent(this.getParent());\n\n        // Compile\n        const clonedCompiler = compiler.clone();\n\n        // Define locale variables\n        argumentNodes.forEach((argNode) => {\n            const compiledValue = expressionCompiler.compileExpressionIntoValue(compiler, argNode.getAttribute('value') as ExpressionNode);\n            clonedCompiler.defineLocal(argNode.getVariableName(), compiledValue);\n        });\n\n        // Check if include is being used in the root (AstNode)\n        if (this.getParent() instanceof AstNode) {\n            clonedCompiler.compile(ast);\n        } else {\n            // Nope, so we compile it with vgap\n            compilerHelpers.compileWithVgap(clonedCompiler, ast.getChildren());\n        }\n\n        compiler.import(clonedCompiler);\n\n        compiler.writeHead(clonedCompiler.getHead());\n        compiler.write(clonedCompiler.getBody());\n\n        compiler.flushLocalVariables();\n    }\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\n\nexport default class ArrowNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\t\tif (parser.acceptWithValue(TokenType.SYMBOL, '-') && parser.expectAtWithValue(TokenType.SYMBOL, 1, '>')) {\n\t\t\tparser.advance(2);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport ArrowNode from \"./ArrowNode\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class ImgNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'img')) {\n            parser.advance();\n            parser.insert(new ImgNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('src');\n\n            if (ArrowNode.parse(parser)) {\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n    }\n\n    compile(compiler: Compiler) {\n\n        const src = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('src') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const scrollBarWidth = 15;\n        const width = parseInt(compiler.variable('width') as string);\n        const mediaQueryWidth = width + parseInt(compiler.variable('edge') as string) * 2 + scrollBarWidth;\n\n        const imgId = compiler.remember('imgId', parseInt(compiler.get('imgId') as string) + 1);\n        const currWidth = parseInt(compiler.get('currWidth') as string);\n\n        compiler.writeLineToHead(`<style media=\"screen and (min-width:${mediaQueryWidth}px)\">`);\n        compiler.writeLineToHead(`.elos-img-${imgId} {`);\n        compiler.writeLineToHead(`width: ${currWidth}px !important;`);\n        compiler.writeLineToHead('}');\n        compiler.writeLineToHead('</style>');\n\n        if (url) {\n            compiler.writeLineToBody(`<a href=\"${url}\" target=\"_blank\" style=\"text-decoration: none;\">`);\n        }\n\n        compiler.writeLineToBody(`<img class=\"elos-img-${imgId}\" border=\"0\" src=\"${src}\" style=\"display:block; border: 0; width: 100%;\"/>`);\n\n        if (url) {\n            compiler.writeLineToBody(`</a>`);\n        }\n    }\n}\n","import Compiler from \"../../compiler/Compiler\";\n\nconst propMap = {\n    font: {\n        type: 'string',\n        cssProperty: 'font-family',\n    },\n    size: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'font-size'\n    },\n    weight: {\n        type: 'string',\n        cssProperty: 'font-weight'\n    },\n    line: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'line-height'\n    },\n    height: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'height'\n    },\n    width: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'weight'\n    },\n    transform: {\n        type: 'string',\n        cssProperty: 'text-transform'\n    },\n    color: {\n        type: 'string',\n        cssProperty: 'color'\n    },\n    bgcolor: {\n        type: 'string',\n        cssProperty: 'background-color'\n    },\n    rounded: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'border-radius'\n    },\n    padding: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'padding'\n    },\n    align: {\n        type: 'string',\n        cssProperty: 'text-align'\n    }\n};\n\nexport default {\n    compileStyleAttrs(compiler: Compiler, ident: string, className: string = null, defaults = {}) {\n\n        const name = (className ? className : ident);\n        const styles = (className ? compiler.get('classes') : compiler.get('identStyles'));\n        const properties = styles[name] || [];\n        const css = defaults;\n\n        properties.forEach(prop => {\n\n            let cssProp = '';\n            let type = 'string';\n\n            if (propMap[prop[0]]) {\n\n                type = propMap[prop[0]]['type'];\n                cssProp = propMap[prop[0]]['cssProperty'];\n\n                switch (type) {\n                    case 'string':\n                        css[cssProp] = prop[1];\n                        break;\n                    case 'integer':\n                        const unit = (propMap[prop[0]]['unit'] ? 'px' : '');\n                        css[cssProp] = parseInt(prop[1])+unit;\n                        break;\n                }\n            }\n        });\n\n        return css;\n    },\n    attrsToCssString(cssProps) {\n        let output = '';\n\n        for (let prop in cssProps) {\n            output += `${prop}: ${cssProps[prop]};`;\n        }\n\n        return output;\n    }\n};\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class LineNode extends Node {\n\n  static parse(parser: Parser): boolean {\n    if (parser.acceptWithValue(TokenType.IDENT, \"line\")) {\n      parser.advance();\n      parser.insert(new LineNode());\n      parser.traverseUp();\n\n      let className = parseClass(parser);\n      if (className) {\n        parser.setAttribute('className', className);\n      }\n\n      parser.traverseDown();\n      return true;\n    }\n\n    return false;\n  }\n\n  compile(compiler: Compiler) {\n\n    const className = this.getAttribute('className') as string || null;\n    const width = parseInt(compiler.variable(\"width\") as string);\n\n    const css = styleCompiler.compileStyleAttrs(\n      compiler,\n      \"line\",\n      className,\n      {\n        height: \"2px\",\n        \"background-color\": \"#000000\",\n      }\n    );\n\n    const cssString = styleCompiler.attrsToCssString(css);\n\n    compiler.writeLineToBody(\n      `<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`\n    );\n    compiler.writeLineToBody(\"<tr>\");\n    compiler.writeLineToBody(`<td style=\"${cssString}\"></td>`);\n    compiler.writeLineToBody(\"</tr>\");\n    compiler.writeLineToBody(\"</table>\");\n  }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport ArrowNode from \"./ArrowNode\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class TxtNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'txt')) {\n            parser.advance();\n            parser.insert(new TxtNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('text');\n\n            if (ArrowNode.parse(parser)) {\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const text = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('text') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const width = compiler.variable('width');\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'txt', className, {\n            'font-family': 'Arial',\n            'font-size': '12px',\n            'color': '#000000',\n            'line-height': '16px',\n            'text-decoration': 'none'\n        });\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLineToBody(`<table cellspacing=\"0\" cellpadding=\"0\" style=\"max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td style=\"${cssString}\">`);\n\n        if (url) {\n            compiler.writeLineToBody(`<a href=\"${url}\" target=\"_blank\" style=\"${cssString}\">`);\n        }\n\n        compiler.writeLineToBody(text);\n\n        if (url) {\n            compiler.writeLineToBody(`</a>`);\n        }\n\n        compiler.writeLineToBody(`</td>`);\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\n\nexport default class RawNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'raw')) {\n            parser.advance();\n            parser.insert(new RawNode());\n            parser.traverseUp();\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('expression');\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        (this.getAttribute('expression') as ExpressionNode).compile(compiler);\n    }\n}\n","import Compiler from \"../Compiler\";\nimport Node from \"../../parser/Node\";\nimport RawNode from \"../../nodes/RawNode\";\nimport {AlignmentOption} from \"../../types/alignment-option\";\n\nexport default {\n    compileWithVgap(compiler: Compiler, children: Node[], align: AlignmentOption = AlignmentOption.LEFT) {\n\n        const totalChildrenCount = children.length;\n        const rawChildrenCount = children.filter(child => child instanceof RawNode).length;\n        const otherChildrenCount = totalChildrenCount - rawChildrenCount;\n\n        const hasOnlyRawChildren = otherChildrenCount === 0;\n\n        const vgap = compiler.variable('vgap');\n        const cssString = (align === AlignmentOption.CENTER ? '' : 'width: 100%;');\n\n        if (totalChildrenCount) {\n\n            if (! hasOnlyRawChildren) {\n                compiler.writeLineToBody(`<table role=\"presentation\" style=\"${cssString}border:none;border-spacing:0;text-align:${align};font-family:Arial,sans-serif;font-size:16px;line-height:22px;color:#363636;\">`);\n            }\n\n            let otherChildIndex = 0;\n            children.forEach((child, index) => {\n\n                if (child instanceof RawNode) {\n                    child.compile(compiler);\n                } else {\n                    compiler.writeLineToBody('<tr>');\n                    compiler.writeLineToBody(`<td align=\"${align}\">`);\n                    child.compile(compiler);\n                    compiler.writeLineToBody('</td>');\n                    compiler.writeLineToBody('</tr>');\n                    if (otherChildIndex < otherChildrenCount - 1) {\n                        compiler.writeLineToBody(`<tr><td height=\"${vgap}\"></td></tr>`);\n                    }\n\n                    otherChildIndex++;\n                }\n            });\n\n            if (! hasOnlyRawChildren) {\n                compiler.writeLineToBody(`</table>`);\n            }\n        }\n    }\n};\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport {AlignmentOption} from \"../types/alignment-option\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class GroupNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'group')) {\n            parser.advance();\n\n            let className = parseClass(parser);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                const groupNode = new GroupNode();\n\n                if (className) {\n                    groupNode.setAttribute('className', className);\n                }\n\n                parser.insert(groupNode);\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const currentWidth = compiler.get('currWidth') as string;\n        const className= this.getAttribute('className') as string || null;\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'group', className, {\n            'background-color': '#f0f0f0',\n            'padding': '25px',\n            'text-align': 'left'\n        });\n\n        const bgColor = css['background-color'];\n        const padding = parseInt(css['padding']);\n        const align = css['text-align'] as AlignmentOption;\n\n        const currWidth = parseInt(currentWidth);\n        compiler.remember('currWidth', currWidth - (padding*2));\n\n        compiler.writeLineToBody(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width:100%;max-width:${currWidth}px;border:none;border-spacing:0;text-align:${align};\">`);\n\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" height=\"${padding}\"></td>`);\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody('</tr>');\n\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" align=\"${align}\">`);\n\n        compilerHelpers.compileWithVgap(compiler, this.getChildren(), align);\n\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody('</tr>');\n\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" height=\"${padding}\"></td>`);\n        compiler.writeLineToBody(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLineToBody('</tr>');\n\n        compiler.writeLineToBody('</table>');\n\n        compiler.remember('currWidth', currWidth);\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport config from \"../grammar\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\n\nexport default class ColNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'col')) {\n            parser.advance();\n\n            if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new ColNode());\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n\n        }\n\n        return false;\n    }\n\n    compile(compiler) {\n        compilerHelpers.compileWithVgap(compiler, this.getChildren());\n    }\n}\n","import Node from \"../parser/Node\";\nimport ColNode from \"./ColNode\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\n\nexport default class ColsNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'cols')) {\n            parser.advance();\n\n            let className = parseClass(parser);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                const colsNode = new ColsNode();\n\n                if (className) {\n                    colsNode.setAttribute('className', className);\n                }\n\n                parser.insert(colsNode);\n                parser.in();\n\n                while (ColNode.parse(parser));\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const colsId = compiler.remember('colsId', parseInt(compiler.get('colsId') as string) + 1);\n\n        const scrollBarWidth = 15;\n        const colCount = this.getChildren().length;\n        const currWidth = parseInt(compiler.get('currWidth') as string);\n        const width = parseInt(compiler.variable('width') as string);\n        const mediaQueryWidth = width + parseInt(compiler.variable('edge') as string) * 2 + scrollBarWidth;\n        const gap = parseInt(compiler.variable('hgap') as string);\n        const colWidth = Math.floor((currWidth / colCount) - gap + Math.floor(gap / colCount));\n\n        compiler.writeLineToBody(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${currWidth}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody('<td>');\n\n        compiler.writeLineToBody('<!--[if mso]>');\n        compiler.writeLineToBody('<table role=\"presentation\" width=\"100%\">');\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody('<![endif]-->');\n\n        this.getChildren().forEach((child, i) => {\n\n            compiler.remember('currWidth', colWidth);\n\n            compiler.writeLineToHead(`<style media=\"screen and (min-width:${mediaQueryWidth}px)\">`);\n            compiler.writeLineToHead(`.elos-col-${colsId}-${i} {`);\n            compiler.writeLineToHead(`float: left;`);\n            compiler.writeLineToHead(`max-width: ${colWidth}px !important;`);\n            //compiler.writeLnHead(`padding-left: ${gap/2}px;`);\n            compiler.writeLineToHead(`margin-bottom: 0 !important;`);\n\n            if (i < colCount-1) {\n                compiler.writeLineToHead(`padding-right: ${gap}px !important;`);\n            }\n\n            if (i===0) {\n                //compiler.writeLnHead(`margin-left: -${gap/2}px;`);\n            }\n\n            compiler.writeLineToHead('}');\n            compiler.writeLineToHead('</style>');\n\n            compiler.writeLineToBody('<!--[if mso]>');\n            compiler.writeLineToBody(`<td style=\"width: ${colWidth}px; padding: 0;\" align=\"left\" valign=\"top\">`);\n            compiler.writeLineToBody('<![endif]-->');\n            compiler.writeLineToBody(`<div class=\"elos-col-${colsId}-${i}\" style=\"display:inline-block; margin-bottom: ${gap}px; width:100%; vertical-align:top; text-align:left;\">`);\n\n            child.compile(compiler);\n\n            compiler.writeLineToBody('</div>');\n            compiler.writeLineToBody('<!--[if mso]>');\n            compiler.writeLineToBody('</td>');\n            compiler.writeLineToBody('<![endif]-->');\n\n        });\n\n        compiler.remember('currWidth', currWidth);\n\n        compiler.writeLineToBody('<!--[if mso]>');\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n        compiler.writeLineToBody('<![endif]-->');\n\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class SpaceNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'space')) {\n\n            parser.advance();\n            parser.insert(new SpaceNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const className = this.getAttribute('className') as string || null;\n        const vgap = compiler.variable('vgap') as string;\n        const width = compiler.variable('width') as string;\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'space', className,{\n            'height': `${vgap}px`\n        });\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLineToBody(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td style=\"${cssString}\"></td>`);\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ArrowNode from \"./ArrowNode\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class BtnNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'btn')) {\n\n            parser.advance();\n            parser.insert(new BtnNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('text');\n\n            if (ArrowNode.parse(parser)) {\n\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const expression = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('text') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const width = compiler.get('currWidth');\n\n        let css = styleCompiler.compileStyleAttrs(compiler, 'btn', className, {\n            'background-color': '#000000',\n            'color': '#ffffff',\n            'border-radius': '8px',\n            'font-size': '12px',\n            'font-weight': 'normal',\n            'line-height': '16px',\n            'text-decoration': 'none',\n            'text-transform': 'none',\n            'padding': '8px 16px'\n        });\n\n        const bgColor = css['background-color'];\n        const padding = css['padding'];\n        const borderRadius = css['border-radius'];\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLineToBody(`<table border=\"0\" cellPadding=\"0\" cellSpacing=\"0\" role=\"presentation\" style=\"border-collapse:separate;line-height:100%;\">`);\n        compiler.writeLineToBody('<tbody>');\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td align=\"center\" bgcolor=\"${bgColor}\" role=\"presentation\" style=\"border:none;border-radius:${borderRadius};cursor:auto;mso-padding-alt:${padding};background:${bgColor};\" valign=\"middle\">`);\n        compiler.writeLineToBody(`<a href=\"${url ? url : '#'}\" style=\"display:inline-block;margin:0;${cssString}\" target=\"_blank\">`);\n        compiler.writeLineToBody(expression);\n        compiler.writeLineToBody('</a>');\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</tbody>');\n        compiler.writeLineToBody('</table>');\n    }\n}\n","import ImgNode from \"../../nodes/ImgNode\";\nimport LineNode from \"../../nodes/LineNode\";\nimport TxtNode from \"../../nodes/TxtNode\";\nimport GroupNode from \"../../nodes/GroupNode\";\nimport ColsNode from \"../../nodes/ColsNode\";\nimport SpaceNode from \"../../nodes/SpaceNode\";\nimport BtnNode from \"../../nodes/BtnNode\";\nimport Parser from \"../Parser\";\nimport IncludeNode from \"../../nodes/IncludeNode\";\nimport RawNode from \"../../nodes/RawNode\";\n\nexport default function parseBody(parser: Parser) {\n\n  while(\n    IncludeNode.parse(parser) ||\n    SpaceNode.parse(parser) ||\n    ColsNode.parse(parser) ||\n    GroupNode.parse(parser) ||\n    ImgNode.parse(parser) ||\n    LineNode.parse(parser) ||\n    TxtNode.parse(parser) ||\n    BtnNode.parse(parser) ||\n    RawNode.parse(parser)\n  );\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class FontNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\n\t\tif (parser.acceptWithValue(TokenType.IDENT, 'font')) {\n\t\t\tparser.advance();\n\t\t\tparser.insert(new FontNode());\n\t\t\tparser.traverseUp();\n\n\t\t\tif (! ExpressionNode.parse(parser)) {\n\t\t\t\tthrow new Error('Expected an expression');\n\t\t\t}\n\t\t\tparser.setAttribute('fontSrc');\n\n\t\t\tparser.traverseDown();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcompile(compiler: Compiler) {\n\n\t\t// Compile fileName expression\n\t\tconst fontSrc = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('fontSrc') as ExpressionNode);\n\n\t\tcompiler.writeHead(`\n\t\t\t<style>\n\t\t\t@import url('${fontSrc}');\n\t\t\t</style>\n\t\t`);\n\t}\n}\n","import Parser from \"../Parser\";\nimport IncludeNode from \"../../nodes/IncludeNode\";\nimport DefNode from \"../../nodes/DefNode\";\nimport StyleNode from \"../../nodes/StyleNode\";\nimport FontNode from \"../../nodes/FontNode\";\n\nexport default function parseHead(parser: Parser) {\n\n\twhile(\n\t\tDefNode.parse(parser) ||\n\t\tStyleNode.parse(parser) ||\n\t\tIncludeNode.parse(parser) ||\n\t\tFontNode.parse(parser)\n\t);\n}\n","import {EventListener} from \"../types/event-listener\";\nimport {EventQueueTuple} from \"../types/event-queue-tuple\";\n\nexport class Manager {\n\n\t/**\n\t * @private\n\t */\n\tprivate static listeners: Record<string, EventListener[]> = {};\n\n\t/**\n\t * @private\n\t */\n\tprivate static queue: Array<EventQueueTuple> = []\n\n\t/**\n\t * Adds an event listener to the manager\n\t * @param id\n\t * @param listener\n\t */\n\tstatic addListener(id: string, listener: EventListener): void {\n\t\tif (! this.listeners[id]) {\n\t\t\tthis.listeners[id] = [];\n\t\t}\n\n\t\tthis.listeners[id] = [\n\t\t\t...this.listeners[id],\n\t\t\tlistener\n\t\t];\n\t}\n\n\t/**\n\t * Emits an event\n\t * @param id\n\t * @param data\n\t */\n\tstatic emit(id: string, data: object): void {\n\t\tif (! this.listeners || ! this.listeners[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listeners[id].forEach(listener => this.queue.push([listener, data]));\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Process the event queue\n\t */\n\tstatic process(): void {\n\t\tif (! this.queue.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.queue.forEach(queueItem => {\n\t\t\tconst [listener, data] = queueItem;\n\t\t\tlistener(data);\n\t\t});\n\n\t\t// Empty the queue\n\t\tthis.queue = [];\n\t}\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class ArgumentNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.VAR)) {\n\n            parser.insert(new ArgumentNode(parser.getCurrentValue()));\n            parser.advance();\n            parser.traverseUp();\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('value');\n\n            parser.traverseDown();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    public getVariableName(): string {\n        return this.getValue();\n    }\n\n    compile(compiler: Compiler) {\n        /*\n        const value = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('value') as ExpressionNode);\n\n        compiler.define(this.getVariableName(), value);\n        */\n    }\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport ArgumentNode from \"./ArgumentNode\";\nimport grammar from \"../grammar\";\n\nexport default class ArgumentListNode extends Node {\n\n    static parse(parser: Parser): boolean {\n        if (parser.skipWithValue(TokenType.SYMBOL, grammar.ARG_LIST_OPEN_SYMBOL)) {\n\n            parser.insert(new ArgumentListNode());\n            parser.traverseUp();\n\n            this.parseArgumentNodes(parser);\n\n            if (parser.skipWithValue(TokenType.SYMBOL, grammar.ARG_LIST_CLOSE_SYMBOL)) {\n                parser.traverseDown();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private static parseArgumentNodes(parser: Parser) {\n        if (ArgumentNode.parse(parser)) {\n            if (parser.skipWithValue(TokenType.SYMBOL, ',')) {\n                this.parseArgumentNodes(parser);\n            }\n        }\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport config from \"../grammar\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class BodyNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'body')) {\n            parser.advance();\n\n            if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new BodyNode());\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const preview = compiler.variable('preview') as string;\n\n        const width = parseInt(compiler.variable('width') as string);\n        const edge = parseInt(compiler.variable('edge') as string);\n        const totalWidth = width+edge*2;\n\n        compiler.remember('currWidth', width);\n\n        if (preview) {\n            compiler.writeLineToBody('<div style=\"display:none;font-size:1px;color:#ffffff;line-height:1px;max-height:0;max-width:0;opacity:0;overflow:hidden;\">');\n            compiler.writeLineToBody(preview);\n            compiler.writeLineToBody(`</div>`);\n        }\n\n        compiler.writeLineToBody('<table role=\"presentation\" style=\"width:100%;border:none;border-spacing:0;\">');\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody('<td align=\"center\" style=\"padding:0;\">');\n\n        compiler.writeLineToBody(`<table role=\"presentation\" style=\"width:100%;max-width:${totalWidth}px;border:none;border-spacing:0;text-align:left;font-family:Arial,sans-serif;font-size:16px;line-height:22px;color:#363636;\">`);\n        compiler.writeLineToBody('<tr>');\n        compiler.writeLineToBody(`<td width=\"${edge}\">`);\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody(`<td style=\"max-width: ${width}px;\">`);\n\n        compilerHelpers.compileWithVgap(compiler, this.getChildren());\n\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody(`<td width=\"${edge}\">`);\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n\n        compiler.writeLineToBody('</td>');\n        compiler.writeLineToBody('</tr>');\n        compiler.writeLineToBody('</table>');\n    }\n}\n","import Node from \"./Node\";\nimport Compiler from \"../compiler/Compiler\";\nimport Parser from \"./Parser\";\nimport DefNode from \"../nodes/DefNode\";\nimport StyleNode from \"../nodes/StyleNode\";\nimport IncludeNode from \"../nodes/IncludeNode\";\nimport BodyNode from \"../nodes/BodyNode\";\nimport FontNode from \"../nodes/FontNode\";\n\nexport default class AstNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        while (\n            DefNode.parse(parser) ||\n            StyleNode.parse(parser) ||\n            IncludeNode.parse(parser) ||\n            FontNode.parse(parser)\n        );\n\n        if (BodyNode.parse(parser)) {\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => child.compile(compiler));\n    }\n}\n","import {Token} from \"../types/token\";\nimport {TokenType} from \"../types/token-type\";\nimport {Nullable} from \"../types/nullable\";\n\nexport default class UnexpectedToken extends Error {\n\tconstructor(expected: Nullable<TokenType>, got: Token) {\n\n\t\tif (! expected) {\n\t\t\tsuper(`Unexpected token ${got.type}(${got.value}) at line ${got.line},${got.position}`);\n\t\t} else {\n\t\t\tsuper(`Expected a token with type ${expected ?? 'unknown'}, got ${got.type}(${got.value}) at line ${got.line},${got.position}`);\n\t\t}\n\n\t\tthis.name = \"UnexpectedToken\";\n\t}\n}","import {TokenStream} from \"../types/token-stream\";\nimport Node from \"./Node\";\nimport AstNode from \"./AstNode\";\nimport {TokenType} from \"../types/token-type\";\nimport UnexpectedToken from \"../errors/UnexpectedToken\";\nimport {Nullable} from \"../types/nullable\";\n\nexport default class Parser {\n\n    /**\n     *\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     *\n     * @private\n     */\n    private tokens: TokenStream;\n\n    /**\n     *\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     *\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     *\n     * @param tokens\n     */\n    setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     *\n     * @param tokens\n     */\n    parse(tokens: TokenStream): AstNode {\n        this.setTokenStream(tokens);\n        this.parseAll();\n        return this.ast;\n    }\n\n    /**\n     *\n     */\n    parseAll() {\n\n        if (! this.tokens.length) {\n            return;\n        }\n\n        if (this.cursor > (this.tokens.length-1)) {\n            return;\n        }\n\n        if (AstNode.parse(this)) {\n            this.parseAll();\n        }\n    }\n\n    /**\n     *\n     */\n    getCurrentToken() {\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     *\n     * @param offset\n     */\n    getOffsetToken(offset: number) {\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     *\n     */\n    getCurrentValue() {\n        return this.getCurrentToken().value;\n    }\n\n    /**\n     *\n     * @param offset\n     */\n    advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     *\n     * @param type\n     */\n    accept(type: TokenType): boolean {\n        let token = this.getCurrentToken();\n        return (token && token.type === type);\n    }\n\n    /**\n     *\n     * @param type\n     */\n    expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     */\n    skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     */\n    acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        return (token && token.type === type);\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    expectWithValue(type: TokenType, value: string): boolean {\n\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     * @param value\n     */\n    expectAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        if (this.acceptAtWithValue(type, offset, value)) {\n            return true;\n        }\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     * @param value\n     */\n    acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     *\n     */\n    in() {\n        this.scope = this.getLastNode();\n    }\n\n    /**\n     *\n     */\n    out() {\n        this.scope = this.scope.getParent();\n    }\n\n    /**\n     *\n     */\n    getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     *\n     */\n    getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     *\n     * @param node\n     */\n    insert(node: Node) {\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     *\n     */\n    traverseUp() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     *\n     */\n    traverseDown() {\n        this.setScope(this.getScope().getParent());\n    }\n\n    /**\n     *\n     * @param node\n     */\n    wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     *\n     */\n    getAst(): AstNode {\n        return this.ast;\n    }\n}\n","import Compiler from \"./compiler/Compiler\";\nimport Lexer from \"./lexer/Lexer\";\nimport Parser from \"./parser/Parser\";\nimport {EventListener} from \"./types/event-listener\";\nimport {Manager} from \"./events/Manager\";\nimport Runtime from \"./runtime/Runtime\";\n\nexport default class Elos {\n\n\t/**\n\t * @param code\n\t * @param path\n\t */\n\tpublic static make(code: string, path: string = '') {\n\t\tconst tokens = (new Lexer()).tokenize(code);\n\t\tconst ast = (new Parser()).parse(tokens);\n\n\t\tconst runtime = new Runtime();\n\t\truntime.setInternalMemoryItem('path', path);\n\n\t\treturn (new Compiler(runtime)).compile(ast);\n\t}\n\n\t/**\n\t * @param eventId\n\t * @param listener\n\t */\n\tpublic static on(eventId: string, listener: EventListener) {\n\t\tManager.addListener(eventId, listener);\n\t}\n}\n"],"mappings":";AAAA,IAAqB,QAArB,MAA8B;AAAA;AAAA;AAAA;AAAA,EAKrB,QAA2B,CAAC;AAAA;AAAA;AAAA;AAAA,EAKpC,YAAY,QAA2B,CAAC,GAAG;AAC1C,SAAK,QAAQ;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,IAAI,MAAc,OAAa;AACrC,SAAK,MAAM,IAAI,IAAI;AACnB,WAAO;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,IAAI,MAAwB;AAClC,WAAO,KAAK,MAAM,IAAI,KAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKO,SAA4B;AAClC,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAO,OAA0B;AACvC,WAAO,OAAO,KAAK,OAAO,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKO,QAAc;AACpB,SAAK,QAAQ,CAAC;AAAA,EACf;AACD;;;AClDA,IAAqB,UAArB,MAAqB,SAAQ;AAAA,EAEpB,WAAW,IAAI,MAAW;AAAA,IACjC,MAAM;AAAA,IACN,QAAQ;AAAA,IACR,OAAO;AAAA,IACP,SAAS,CAAC;AAAA,IACV,aAAa,CAAC;AAAA,EACf,CAAC;AAAA,EAEO,kBAAkB,IAAI,MAAsB;AAAA,IACnD,SAAS;AAAA,IACT,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,SAAS;AAAA,IACT,OAAO;AAAA,EACR,CAAC;AAAA,EAEO,iBAAiB,IAAI,MAAsB,CAAC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAM9C,iBAAiB,MAAc,OAAuB;AAC5D,WAAO,KAAK,eAAe,IAAI,MAAM,KAAK;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA,EAKO,iBAAiB,MAA8B;AACrD,WAAO,KAAK,eAAe,IAAI,IAAI;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKO,oBAA2C;AACjD,WAAO,KAAK;AAAA,EACb;AAAA;AAAA;AAAA;AAAA,EAKO,sBAAsB;AAC5B,SAAK,eAAe,MAAM;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,YAAY,MAAc,OAAuB;AACvD,WAAO,KAAK,gBAAgB,IAAI,MAAM,KAAK;AAAA,EAC5C;AAAA,EAEO,YAAY,MAA8B;AAChD,WAAO,KAAK,gBAAgB,IAAI,IAAI;AAAA,EACrC;AAAA,EAEO,eAAsC;AAC5C,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,sBAAsB,MAAc,OAAiB;AAC3D,WAAO,KAAK,SAAS,IAAI,MAAM,KAAK;AAAA,EACrC;AAAA,EAEO,sBAAsB,MAAmB;AAC/C,WAAO,KAAK,SAAS,IAAI,IAAI;AAAA,EAC9B;AAAA,EAEO,oBAAgC;AACtC,WAAO,KAAK;AAAA,EACb;AAAA,EAEO,QAAiB;AACvB,UAAM,UAAU,IAAI,SAAQ;AAC5B,YAAQ,OAAO,IAAI;AACnB,WAAO;AAAA,EACR;AAAA,EAEO,OAAO,SAAkB;AAC/B,SAAK,SAAS,OAAO,QAAQ,kBAAkB,EAAE,OAAO,CAAC;AACzD,SAAK,gBAAgB,OAAO,QAAQ,aAAa,EAAE,OAAO,CAAC;AAC3D,SAAK,eAAe,OAAO,QAAQ,kBAAkB,EAAE,OAAO,CAAC;AAAA,EAChE;AACD;;;AC5FA,IAAqB,eAArB,MAAkC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,OAAiB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,OAAiB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,OAAiB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1B,UAAU,QAAgB;AACzB,SAAK,KAAK,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,QAAgB;AACzB,SAAK,KAAK,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,QAAgB;AACzB,SAAK,KAAK,KAAK,MAAM;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACjB,WAAO,KAAK,KAAK,KAAK,EAAE;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACjB,WAAO,KAAK,KAAK,KAAK,EAAE;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACjB,WAAO,KAAK,KAAK,KAAK,EAAE;AAAA,EACzB;AACD;;;AC5DA,IAAqB,iBAArB,MAAoC;AAAA,EAEnC,OAAO,QAAsB,WAAkC;AAC9D,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAgBL,OAAO,QAAQ,CAAC;AAAA;AAAA,kBAEF,UAAU,IAAI,SAAS,CAAC;AAAA,IACtC,OAAO,QAAQ,CAAC;AAAA;AAAA;AAAA;AAAA,EAInB;AACD;;;ACzBA,IAAqB,WAArB,MAAqB,UAAS;AAAA;AAAA;AAAA;AAAA;AAAA,EAMT;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKT;AAAA;AAAA;AAAA;AAAA,EAKR,YAAY,UAAmB,MAAM;AACjC,SAAK,UAAU,UAAU,UAAU,IAAI,QAAQ;AAC/C,SAAK,SAAS,IAAI,aAAa;AAC/B,SAAK,WAAW,IAAI,eAAe;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAkB;AACd,WAAO,IAAI,UAAS,KAAK,QAAQ,MAAM,CAAC;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,UAAoB;AACvB,SAAK,QAAQ,OAAO,SAAS,WAAW,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,aAAsB;AAClB,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAgB;AAClB,SAAK,OAAO,UAAU,MAAM;AAAA,EAChC;AAAA,EAEA,UAAU,QAAgB;AACtB,SAAK,OAAO,UAAU,MAAM;AAAA,EAChC;AAAA,EAEA,gBAAgB,QAAgB;AAC5B,SAAK,OAAO,UAAU,OAAK,MAAM;AAAA,EACrC;AAAA,EAEA,gBAAgB,QAAgB;AAC5B,SAAK,OAAO,UAAU,OAAK,MAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,MAAc,OAAuC;AAC7D,SAAK,QAAQ,iBAAiB,MAAM,KAAK;AACzC,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsB;AAClB,SAAK,QAAQ,oBAAoB;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,MAAc,OAAuC;AACxD,SAAK,QAAQ,YAAY,MAAM,KAAK;AACpC,WAAO;AAAA,EACX;AAAA,EAEA,SAAS,MAA8B;AACnC,QAAI,KAAK,QAAQ,iBAAiB,IAAI,GAAG;AACrC,aAAO,KAAK,QAAQ,iBAAiB,IAAI;AAAA,IAC7C;AAEA,WAAO,KAAK,QAAQ,YAAY,IAAI;AAAA,EACxC;AAAA,EAEA,SAAS,MAAc,OAAuB;AAC1C,WAAO,KAAK,QAAQ,sBAAsB,MAAM,KAAK;AAAA,EACzD;AAAA,EAEA,IAAI,MAA8B;AAC9B,WAAO,KAAK,QAAQ,sBAAsB,IAAI;AAAA,EAClD;AAAA,EAEA,UAAkB;AACd,WAAO,KAAK,OAAO,QAAQ;AAAA,EAC/B;AAAA,EAEA,UAAkB;AACd,WAAO,KAAK,OAAO,QAAQ;AAAA,EAC/B;AAAA,EAEA,QAAQ,KAAW;AACf,QAAI,QAAQ,IAAI;AAChB,WAAO,KAAK,SAAS,OAAO,KAAK,QAAQ,KAAK,QAAQ,aAAa,CAAC;AAAA,EACxE;AACJ;;;AChIA,IAAO,kBAAQ;AAAA,EAEX,aAAa;AAAA,EACb,cAAc;AAAA,EACd,cAAc;AAAA,EACd,kBAAkB;AAAA,EAClB,eAAe;AAAA,EACf,wBAAwB;AAAA,EAExB,WAAW;AAAA,EACX,iBAAiB;AAAA,EAEjB,aAAa;AAAA,EACb,mBAAmB;AAAA,EAEnB,gBAAgB;AAAA,EAEhB,mBAAmB;AAAA,EACnB,oBAAoB;AAAA,EAEpB,sBAAsB;AAAA,EACtB,uBAAuB;AAAA,EAEvB,sBAAsB;AAAA,EAEtB,sBAAsB;AAC1B;;;ACrBA,IAAqB,QAArB,MAA2B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,kBAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,EAM1B,OAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAMf,SAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpB,gBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxB,MAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAMd,SAAsB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvB,QAAgB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhB,YAAoB;AAAA;AAAA;AAAA;AAAA;AAAA,EAM5B,SAAS,MAA2B;AAEhC,SAAK,SAAS;AACd,SAAK,MAAM,KAAK,OAAO;AAEvB,WAAO,KAAK,SAAS,KAAK,KAAK;AAE3B,WAAK,YAAY,KAAK,OAAO,KAAK,MAAM;AACxC,WAAK,gBAAgB,KAAK,OAAO,KAAK,SAAO,CAAC,KAAK;AAGnD,UAAI,KAAK,sBAAsB;AAC3B,aAAK,OAAO,KAAK,cAAc;AAC/B,aAAK,kBAAkB,KAAK;AAAA,MAChC;AAEA,cAAQ,KAAK,MAAM;AAAA,QACf;AACI,eAAK,UAAU;AACf;AAAA,QACJ;AACI,eAAK,SAAS;AACd;AAAA,QACJ;AACI,eAAK,UAAU;AACf;AAAA,QACJ;AACI,eAAK,UAAU;AACf;AAAA,QACJ;AACI,eAAK,WAAW;AAChB;AAAA,QACJ;AACI,eAAK,cAAc;AACnB;AAAA,QACJ;AACI,eAAK,YAAY;AACjB;AAAA,QACJ;AACI,eAAK,SAAS;AACd;AAAA,QACJ;AACI,eAAK,WAAW;AAChB;AAAA,QACJ;AACI,eAAK,WAAW;AAChB;AAAA,MACR;AAAA,IACJ;AAEA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKQ,MAAM,sBAA+B,OAAgB;AACzD,UAAM,SAAS,sBAAsB,IAAI;AACzC,WAAO,KAAK,SAAS,UAAU,KAAK;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,gBAAyB;AAG7B,SAAK,QAAQ;AAEb,QACI,KAAK,cAAc,gBAAQ,kBAC3B,KAAK,kBAAkB,gBAAQ,gBACjC;AACE;AAAA,IACJ;AAEA,QAAI,gBAAQ,YAAY,KAAK,KAAK,SAAS,GAAG;AAC1C;AAAA,IACJ;AAEA,QAAI,gBAAQ,uBAAuB,KAAK,KAAK,SAAS,GAAG;AACrD,WAAK,YAAY,KAAK;AACtB;AAAA,IACJ;AAEA,QAAI,gBAAQ,aAAa,KAAK,KAAK,SAAS,GAAG;AAC3C;AAAA,IACJ;AAEA,QAAI,gBAAQ,kBAAkB,KAAK,KAAK,SAAS,GAAG;AAChD;AAAA,IACJ;AAEA,QAAI,gBAAQ,gBAAgB,KAAK,KAAK,SAAS,GAAG;AAC9C;AAAA,IACJ;AAEA,QAAI,gBAAQ,aAAa,KAAK,KAAK,SAAS,GAAG;AAC3C;AAAA,IACJ;AAEA,QAAI,gBAAQ,cAAc,KAAK,KAAK,SAAS,GAAG;AAC5C;AAAA,IACJ;AAEA,QAAI,gBAAQ,iBAAiB,KAAK,KAAK,SAAS,GAAG;AAC/C;AAAA,IACJ;AAEA;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,WAAW;AAEf,SAAK,SAAS,KAAK;AACnB,SAAK;AAEL,QAAI,CAAE,KAAK,iBAAiB,CAAE,gBAAQ,YAAY,KAAK,KAAK,aAAa,GAAG;AACxE,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK,UAAU,KAAK,MAAM;AAC1B,WAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY;AAEhB,QAAI,cAAe,KAAK,cAAc,gBAAQ;AAG9C,QAAI,aAAa;AACb,WAAK,UAAU;AAGf,WAAK,YAAY,KAAK,OAAO,KAAK,MAAM;AACxC,WAAK,gBAAgB,KAAK,OAAO,KAAK,SAAS,CAAC,KAAK;AAAA,IACzD;AAEA,QAAI,KAAK,cAAc,KAAK,aAAa,aAAa;AAElD,WAAK,SAAS,KAAK;AAAA,IACvB;AAEA,SAAK;AAEL,QAAI,KAAK,kBAAkB,KAAK,WAAW;AACvC,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM,IAAI;AAAA,MACxB,CAAC;AACD,WAAK;AACL,WAAK,UAAU,KAAK,SAAS,KAAK;AAClC,WAAK;AACL,WAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY;AAChB,SAAK,SAAS,KAAK;AACnB,SAAK;AAEL,QAAI,CAAC,KAAK,iBAAiB,CAAC,gBAAQ,aAAa,KAAK,KAAK,aAAa,GAAG;AACvE,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK,UAAU,KAAK,SAAS,KAAK;AAClC,WAAK;AAAA,IACT;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,YAAY;AAEhB,SAAK;AAEL,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,KAAK,KAAK,MAAM;AAAA,IACpB,CAAC;AACD,SAAK;AACL,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa;AACjB,SAAK;AACL,SAAK;AACL,SAAK,SAAS;AACd,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,gBAAgB;AACpB,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,WAAW;AACf,QAAI,gBAAQ,YAAY,KAAK,KAAK,SAAS,GAAG;AAC1C,WAAK,SAAS,KAAK;AAAA,IACvB;AAEA,SAAK;AAEL,QAAI,CAAC,KAAK,iBAAiB,KAAK,MAAM,WAAW,KAAK,CAAC,gBAAQ,YAAY,KAAK,KAAK,aAAa,GAAG;AACjG,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK;AACL,WAAK,UAAU,KAAK,SAAS,KAAK;AAClC,WAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,cAAc;AAClB,QAAI,gBAAQ,UAAU,KAAK,KAAK,SAAS,GAAG;AACxC,WAAK,SAAS,KAAK;AAAA,IACvB;AAEA,SAAK;AAEL,QAAI,CAAC,KAAK,iBAAiB,CAAC,gBAAQ,UAAU,KAAK,KAAK,aAAa,GAAG;AACpE,WAAK,OAAO,KAAK;AAAA,QACb;AAAA,QACA,OAAO,KAAK;AAAA,QACZ,MAAM,KAAK;AAAA,QACX,UAAU,KAAK;AAAA,QACf,KAAK,KAAK,MAAM;AAAA,MACpB,CAAC;AACD,WAAK;AACL,WAAK,UAAU,KAAK,SAAS,KAAK;AAClC,WAAK,YAAY;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa;AACjB,SAAK,OAAO,KAAK;AAAA,MACb;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,KAAK,KAAK,MAAM;AAAA,IACpB,CAAC;AACD,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMQ,aAAa;AACjB,SAAK;AAEL,QAAI,gBAAQ,cAAc,KAAK,KAAK,aAAa,GAAG;AAChD,WAAK;AACL,WAAK;AAAA,IACT;AAAA,EACJ;AACJ;;;ACvYA,IAAqB,OAArB,MAAqB,MAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAMZ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAyB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,WAAmB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpB,aAA6C,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxD,YAAY,QAAgB,IAAI;AAC5B,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAkB;AACd,WAAO,KAAK,YAAY;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,MAAY;AAClB,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,YAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAe;AACpB,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,MAAY;AACjB,SAAK,SAAS,KAAK,IAAI;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACV,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACV,WAAQ,KAAK,SAAS,SAAS;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAc,OAAuB;AAC9C,SAAK,WAAW,IAAI,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,aAAa,MAAwC;AACjD,WAAO,KAAK,WAAW,IAAI,KAAK;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgD;AAC5C,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AACd,SAAK,SAAS,IAAI;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAyB;AAC3B,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,UAAoB;AAAA,EAC5B;AAAA,EAEA,QAAgB;AAEZ,UAAM,YAAY,CAAC,MAAY,eAAuB,MAAc;AAEhE,YAAM,WAAW,KAAK,QAAQ;AAC9B,YAAM,YAAY,KAAK,SAAS;AAEhC,UAAI,aAAa,KAAK,cAAc;AACpC,UAAI,mBAAmB,CAAC;AACxB,eAAS,aAAa,YAAY;AAC9B,YAAI,YAAY,WAAW,SAAS;AACpC,YAAI,qBAAqB,OAAM;AAC3B,gBAAM,gBAAgB,UAAU,SAAS;AACzC,sBAAY,GAAG,UAAU,QAAQ,CAAC,GAAG,gBAAgB,IAAI,aAAa,MAAM,EAAE;AAAA,QAClF;AACA,yBAAiB,KAAK,GAAG,SAAS,IAAI,SAAS,EAAE;AAAA,MACrD;AAEA,UAAI,OAAO,eAAe,IAAI,MAAM,OAAO,eAAe,CAAC,IAAI,uBAAQ;AACvE,UAAI,SAAS,CAAC,GAAG,IAAI,GAAG,QAAQ,GAAG,YAAY,IAAI,SAAS,MAAM,EAAE,IAAI,iBAAiB,KAAK,GAAG,CAAC,EAAE;AAEpG,WAAK,YAAY,EAAE,QAAQ,eAAa;AACpC,eAAO,KAAK,UAAU,WAAW,eAAe,CAAC,CAAC;AAAA,MACtD,CAAC;AAED,aAAO,OAAO,KAAK,IAAI;AAAA,IAC3B;AAEA,WAAO,UAAU,IAAI;AAAA,EACzB;AACJ;;;AC1KA,IAAqB,qBAArB,MAAqB,4BAA2B,KAAK;AAAA,EAEjD,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,0BAAsB,GAAG;AAChC,aAAO,OAAO,IAAI,oBAAmB,OAAO,gBAAgB,CAAC,CAAC;AAC9D,aAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,aAAS,MAAM,IAAI,KAAK,SAAS,CAAC,EAAE;AAAA,EACxC;AACJ;;;ACdA,IAAqB,sBAArB,MAAqB,6BAA4B,KAAK;AAAA,EAElD,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,4BAAuB,GAAG;AACjC,aAAO,OAAO,IAAI,qBAAoB,OAAO,gBAAgB,CAAC,CAAC;AAC/D,aAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,aAAS,MAAM,KAAK,KAAK;AAAA,EAC7B;AACJ;;;AChBA,IAAqB,wBAArB,MAAqB,+BAA8B,KAAK;AAAA,EAEvD,OAAO,MAAM,QAAyB;AAErC,QAAI,OAAO,sBAAoB,GAAG;AACjC,aAAO,OAAO,IAAI,uBAAsB,OAAO,gBAAgB,CAAC,CAAC;AACjE,aAAO,QAAQ;AACf,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,QAAQ,UAAoB;AAC3B,aAAS,MAAM,SAAS,SAAS,KAAK,KAAK,CAAW;AAAA,EACvD;AACD;;;AClBA,IAAqB,eAArB,MAAqB,sBAAqB,KAAK;AAAA,EAE7C,OAAO,MAAM,QAAyB;AACpC,QAAI,OAAO,qCAAgC,GAAG,GAAG;AAC/C,aAAO,OAAO,IAAI,cAAa,GAAG,CAAC;AACnC,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ,UAAoB;AAAA,EAE5B;AACF;;;ACZA,IAAqB,sBAArB,MAAqB,6BAA4B,KAAK;AAAA,EAErD,OAAO,MAAM,QAAyB;AAErC,QAAI,OAAO,4BAAuB,GAAG;AACpC,aAAO,OAAO,IAAI,qBAAoB,OAAO,gBAAgB,CAAC,CAAC;AAC/D,aAAO,QAAQ;AACf,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,QAAQ,UAAoB;AAC3B,aAAS,MAAM,KAAK,KAAK;AAAA,EAC1B;AACD;;;ACdA,IAAqB,iBAArB,MAAqB,wBAAuB,KAAK;AAAA,EAE7C,OAAO,MAAM,QAAyB;AAClC,QACI,oBAAoB,MAAM,MAAM,KAChC,sBAAsB,MAAM,MAAM,KAClC,mBAAmB,MAAM,MAAM,KAC/B,oBAAoB,MAAM,MAAM,GAClC;AAEE,UAAI,OAAO,SAAS,EAAE,QAAQ,MAAM,KAAK,MAAM;AAC3C,eAAO,KAAK,IAAI,gBAAe,CAAC;AAAA,MACpC;AAEA,UAAI,aAAa,MAAM,MAAM,GAAG;AAC5B,YAAI,CAAE,KAAK,MAAM,MAAM,GAAG;AACtB,gBAAM,IAAI,MAAM,sBAAoB,OAAO,gBAAgB,EAAE,IAAI;AAAA,QACrE;AAAA,MACJ,OAAO;AAEH,eAAO,aAAa;AAAA,MACxB;AAEA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,SAAK,YAAY,EAAE,QAAQ,CAAC,OAAO,MAAM;AACrC,YAAM,QAAQ,QAAQ;AAAA,IAC1B,CAAC;AAAA,EACL;AACJ;;;ACvCA,IAAO,wCAAQ;AAAA,EACd,2BAA2B,UAAoB,YAAwD;AAEtG,QAAI,CAAE,YAAY;AACjB,aAAO;AAAA,IACR;AAEA,UAAM,gBAAgB,SAAS,MAAM;AACrC,eAAW,QAAQ,aAAa;AAChC,WAAO,cAAc,QAAQ;AAAA,EAC9B;AACD;;;ACRA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAChD,aAAO,QAAQ;AAEf,YAAM,UAAU,IAAI,SAAQ;AAE5B,aAAO,OAAO,OAAO;AACrB,aAAO,WAAW;AAElB,UAAI,OAAO,sBAAoB,GAAG;AAC9B,gBAAQ,SAAS,OAAO,gBAAgB,CAAC;AACzC,eAAO,QAAQ;AAAA,MACnB;AAEA,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,OAAO;AAE3B,aAAO,aAAa;AACpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,kBAA0B;AAC7B,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EAEA,QAAQ,UAAoB;AACxB,UAAM,QAAQ,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,OAAO,CAAmB;AAElH,aAAS,OAAO,KAAK,gBAAgB,GAAG,KAAK;AAAA,EACjD;AACJ;;;ACvCA,IAAqB,oBAArB,MAAqB,2BAA0B,KAAK;AAAA,EAExC;AAAA,EAER,YAAY,UAAkB,OAAe;AACzC,UAAM,KAAK;AACX,SAAK,WAAW;AAAA,EACpB;AAAA,EAEA,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,0BAAsB,GAAG;AAEhC,UAAI,WAAW,OAAO,gBAAgB;AACtC,aAAO,QAAQ;AAEf,UAAI,OAAO,4BAAuB,KAAK,OAAO,4BAAuB,GAAG;AACpE,YAAI,QAAQ,OAAO,gBAAgB;AACnC,eAAO,QAAQ;AACf,eAAO,OAAO,IAAI,mBAAkB,UAAU,KAAK,CAAC;AAEpD,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,SAAS,KAAK,UAAU;AAC9B,UAAM,OAAO,OAAO,SAAS;AAC7B,UAAM,QAAS,OAAO,UAAU,SAAS,IAAI,SAAS,IAAI,SAAS,IAAI,aAAa;AAEpF,QAAI,CAAE,MAAM,IAAI,GAAG;AACf,YAAM,IAAI,IAAI,CAAC;AAAA,IACnB;AAEA,UAAM,IAAI,IAAI,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,KAAK,UAAU,KAAK,SAAS,CAAC,CAAC;AAAA,EACnE;AACJ;;;AC1Ce,SAAR,WAA4B,QAAkC;AAEjE,MAAI,OAAO,qCAAgC,GAAG,GAAG;AAC7C,WAAO,0BAAsB;AAC7B,QAAI,YAAY,OAAO,gBAAgB;AACvC,WAAO,QAAQ;AACf,WAAO;AAAA,EACX;AAEA,SAAO;AACX;;;ACNA,IAAqB,YAArB,MAAqB,mBAAkB,KAAK;AAAA,EAEjC;AAAA,EAEP,YAAY,MAAc,SAAkB;AACxC,UAAM,IAAI;AACV,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,mCAA+B,OAAO,GAAG;AAEhD,UAAI,aAAa;AAEjB,UAAI,OAAO,0BAAsB,GAAG;AAChC,qBAAa,OAAO,gBAAgB;AACpC,eAAO,QAAQ;AAAA,MACnB;AAEA,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,UAAW,cAAc;AAE7B,UAAI,OAAO,uCAAkC,gBAAO,iBAAiB,GAAG;AACpE,eAAO,QAAQ;AAEf,eAAO,OAAO,IAAI,WAAU,YAAY,YAAY,YAAY,OAAO,CAAC;AACxE,eAAO,GAAG;AAAA,MACd;AAEA,aAAO,kBAAkB,MAAM,MAAM,EAAE;AAEvC,UAAI,OAAO,uCAAkC,gBAAO,kBAAkB,GAAG;AACrE,eAAO,IAAI;AACX,eAAO,QAAQ;AAAA,MACnB;AAEA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,SAAK,YAAY,EAAE,QAAQ,WAAS,MAAM,QAAQ,QAAQ,CAAC;AAAA,EAC/D;AACJ;;;ACtDA,YAAY,QAAQ;;;ACIpB,IAAqB,YAArB,cAAuC,KAAK;AAAA,EAE3C,OAAO,MAAM,QAAyB;AACrC,QAAI,OAAO,uCAAkC,GAAG,KAAK,OAAO,yCAAoC,GAAG,GAAG,GAAG;AACxG,aAAO,QAAQ,CAAC;AAChB,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AACD;;;ACLA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAgB;AAEzB,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAChD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,SAAQ,CAAC;AAC3B,aAAO,WAAW;AAElB,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,WAAW;AACX,eAAO,aAAa,aAAa,SAAS;AAAA,MAC9C;AAEA,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,KAAK;AAEzB,UAAI,UAAU,MAAM,MAAM,GAAG;AACzB,YAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC5C;AACA,eAAO,aAAa,KAAK;AAAA,MAC7B;AAEA,aAAO,aAAa;AAEpB,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,MAAM,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,KAAK,CAAmB;AAC9G,UAAM,YAAY,KAAK,aAAa,WAAW;AAC/C,UAAM,MAAM,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,KAAK,CAAmB;AAE9G,UAAM,iBAAiB;AACvB,UAAM,QAAQ,SAAS,SAAS,SAAS,OAAO,CAAW;AAC3D,UAAM,kBAAkB,QAAQ,SAAS,SAAS,SAAS,MAAM,CAAW,IAAI,IAAI;AAEpF,UAAM,QAAQ,SAAS,SAAS,SAAS,SAAS,SAAS,IAAI,OAAO,CAAW,IAAI,CAAC;AACtF,UAAM,YAAY,SAAS,SAAS,IAAI,WAAW,CAAW;AAE9D,aAAS,gBAAgB,uCAAuC,eAAe,OAAO;AACtF,aAAS,gBAAgB,aAAa,KAAK,IAAI;AAC/C,aAAS,gBAAgB,UAAU,SAAS,gBAAgB;AAC5D,aAAS,gBAAgB,GAAG;AAC5B,aAAS,gBAAgB,UAAU;AAEnC,QAAI,KAAK;AACL,eAAS,gBAAgB,YAAY,GAAG,mDAAmD;AAAA,IAC/F;AAEA,aAAS,gBAAgB,wBAAwB,KAAK,qBAAqB,GAAG,oDAAoD;AAElI,QAAI,KAAK;AACL,eAAS,gBAAgB,MAAM;AAAA,IACnC;AAAA,EACJ;AACJ;;;ACpEA,IAAM,UAAU;AAAA,EACZ,MAAM;AAAA,IACF,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,MAAM;AAAA,IACF,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,QAAQ;AAAA,IACJ,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,MAAM;AAAA,IACF,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,QAAQ;AAAA,IACJ,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,OAAO;AAAA,IACH,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,WAAW;AAAA,IACP,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,OAAO;AAAA,IACH,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,SAAS;AAAA,IACL,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,SAAS;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,SAAS;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AAAA,EACA,OAAO;AAAA,IACH,MAAM;AAAA,IACN,aAAa;AAAA,EACjB;AACJ;AAEA,IAAO,8BAAQ;AAAA,EACX,kBAAkB,UAAoB,OAAe,YAAoB,MAAM,WAAW,CAAC,GAAG;AAE1F,UAAM,OAAQ,YAAY,YAAY;AACtC,UAAM,SAAU,YAAY,SAAS,IAAI,SAAS,IAAI,SAAS,IAAI,aAAa;AAChF,UAAM,aAAa,OAAO,IAAI,KAAK,CAAC;AACpC,UAAM,MAAM;AAEZ,eAAW,QAAQ,UAAQ;AAEvB,UAAI,UAAU;AACd,UAAI,OAAO;AAEX,UAAI,QAAQ,KAAK,CAAC,CAAC,GAAG;AAElB,eAAO,QAAQ,KAAK,CAAC,CAAC,EAAE,MAAM;AAC9B,kBAAU,QAAQ,KAAK,CAAC,CAAC,EAAE,aAAa;AAExC,gBAAQ,MAAM;AAAA,UACV,KAAK;AACD,gBAAI,OAAO,IAAI,KAAK,CAAC;AACrB;AAAA,UACJ,KAAK;AACD,kBAAM,OAAQ,QAAQ,KAAK,CAAC,CAAC,EAAE,MAAM,IAAI,OAAO;AAChD,gBAAI,OAAO,IAAI,SAAS,KAAK,CAAC,CAAC,IAAE;AACjC;AAAA,QACR;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,WAAO;AAAA,EACX;AAAA,EACA,iBAAiB,UAAU;AACvB,QAAI,SAAS;AAEb,aAAS,QAAQ,UAAU;AACvB,gBAAU,GAAG,IAAI,KAAK,SAAS,IAAI,CAAC;AAAA,IACxC;AAEA,WAAO;AAAA,EACX;AACJ;;;AC7FA,IAAqB,WAArB,MAAqB,kBAAiB,KAAK;AAAA,EAEzC,OAAO,MAAM,QAAyB;AACpC,QAAI,OAAO,qCAAiC,MAAM,GAAG;AACnD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,UAAS,CAAC;AAC5B,aAAO,WAAW;AAElB,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,WAAW;AACb,eAAO,aAAa,aAAa,SAAS;AAAA,MAC5C;AAEA,aAAO,aAAa;AACpB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,QAAQ,UAAoB;AAE1B,UAAM,YAAY,KAAK,aAAa,WAAW,KAAe;AAC9D,UAAM,QAAQ,SAAS,SAAS,SAAS,OAAO,CAAW;AAE3D,UAAM,MAAM,4BAAc;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,QACE,QAAQ;AAAA,QACR,oBAAoB;AAAA,MACtB;AAAA,IACF;AAEA,UAAM,YAAY,4BAAc,iBAAiB,GAAG;AAEpD,aAAS;AAAA,MACP,sFAAsF,KAAK;AAAA,IAC7F;AACA,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,cAAc,SAAS,SAAS;AACzD,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAAA,EACrC;AACF;;;AC1CA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAgB;AAEzB,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAChD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,SAAQ,CAAC;AAC3B,aAAO,WAAW;AAElB,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,WAAW;AACX,eAAO,aAAa,aAAa,SAAS;AAAA,MAC9C;AAEA,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,MAAM;AAE1B,UAAI,UAAU,MAAM,MAAM,GAAG;AACzB,YAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC5C;AACA,eAAO,aAAa,KAAK;AAAA,MAC7B;AAEA,aAAO,aAAa;AAEpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,OAAO,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,MAAM,CAAmB;AAChH,UAAM,YAAY,KAAK,aAAa,WAAW;AAC/C,UAAM,MAAM,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,KAAK,CAAmB;AAE9G,UAAM,QAAQ,SAAS,SAAS,OAAO;AAEvC,UAAM,MAAM,4BAAc,kBAAkB,UAAU,OAAO,WAAW;AAAA,MACpE,eAAe;AAAA,MACf,aAAa;AAAA,MACb,SAAS;AAAA,MACT,eAAe;AAAA,MACf,mBAAmB;AAAA,IACvB,CAAC;AAED,UAAM,YAAY,4BAAc,iBAAiB,GAAG;AAEpD,aAAS,gBAAgB,2DAA2D,KAAK,oDAAoD;AAC7I,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,cAAc,SAAS,IAAI;AAEpD,QAAI,KAAK;AACL,eAAS,gBAAgB,YAAY,GAAG,4BAA4B,SAAS,IAAI;AAAA,IACrF;AAEA,aAAS,gBAAgB,IAAI;AAE7B,QAAI,KAAK;AACL,eAAS,gBAAgB,MAAM;AAAA,IACnC;AAEA,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAAA,EACvC;AACJ;;;AC1EA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAChD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,SAAQ,CAAC;AAC3B,aAAO,WAAW;AAElB,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,YAAY;AAEhC,aAAO,aAAa;AACpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,IAAC,KAAK,aAAa,YAAY,EAAqB,QAAQ,QAAQ;AAAA,EACxE;AACJ;;;ACzBA,IAAO,4BAAQ;AAAA,EACX,gBAAgB,UAAoB,UAAkB,2BAA+C;AAEjG,UAAM,qBAAqB,SAAS;AACpC,UAAM,mBAAmB,SAAS,OAAO,WAAS,iBAAiB,OAAO,EAAE;AAC5E,UAAM,qBAAqB,qBAAqB;AAEhD,UAAM,qBAAqB,uBAAuB;AAElD,UAAM,OAAO,SAAS,SAAS,MAAM;AACrC,UAAM,YAAa,kCAAmC,KAAK;AAE3D,QAAI,oBAAoB;AAEpB,UAAI,CAAE,oBAAoB;AACtB,iBAAS,gBAAgB,qCAAqC,SAAS,2CAA2C,KAAK,gFAAgF;AAAA,MAC3M;AAEA,UAAI,kBAAkB;AACtB,eAAS,QAAQ,CAAC,OAAO,UAAU;AAE/B,YAAI,iBAAiB,SAAS;AAC1B,gBAAM,QAAQ,QAAQ;AAAA,QAC1B,OAAO;AACH,mBAAS,gBAAgB,MAAM;AAC/B,mBAAS,gBAAgB,cAAc,KAAK,IAAI;AAChD,gBAAM,QAAQ,QAAQ;AACtB,mBAAS,gBAAgB,OAAO;AAChC,mBAAS,gBAAgB,OAAO;AAChC,cAAI,kBAAkB,qBAAqB,GAAG;AAC1C,qBAAS,gBAAgB,mBAAmB,IAAI,cAAc;AAAA,UAClE;AAEA;AAAA,QACJ;AAAA,MACJ,CAAC;AAED,UAAI,CAAE,oBAAoB;AACtB,iBAAS,gBAAgB,UAAU;AAAA,MACvC;AAAA,IACJ;AAAA,EACJ;AACJ;;;ACpCA,IAAqB,YAArB,MAAqB,mBAAkB,KAAK;AAAA,EAExC,OAAO,MAAM,QAAgB;AAEzB,QAAI,OAAO,qCAAiC,OAAO,GAAG;AAClD,aAAO,QAAQ;AAEf,UAAI,YAAY,WAAW,MAAM;AAEjC,UAAI,OAAO,uCAAkC,gBAAO,iBAAiB,GAAG;AACpE,eAAO,QAAQ;AAEf,cAAM,YAAY,IAAI,WAAU;AAEhC,YAAI,WAAW;AACX,oBAAU,aAAa,aAAa,SAAS;AAAA,QACjD;AAEA,eAAO,OAAO,SAAS;AACvB,eAAO,GAAG;AAEV,kBAAU,MAAM;AAEhB,YAAI,OAAO,uCAAkC,gBAAO,kBAAkB,GAAG;AACrE,iBAAO,IAAI;AACX,iBAAO,QAAQ;AAAA,QACnB;AAEA,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,eAAe,SAAS,IAAI,WAAW;AAC7C,UAAM,YAAW,KAAK,aAAa,WAAW,KAAe;AAE7D,UAAM,MAAM,4BAAc,kBAAkB,UAAU,SAAS,WAAW;AAAA,MACtE,oBAAoB;AAAA,MACpB,WAAW;AAAA,MACX,cAAc;AAAA,IAClB,CAAC;AAED,UAAM,UAAU,IAAI,kBAAkB;AACtC,UAAM,UAAU,SAAS,IAAI,SAAS,CAAC;AACvC,UAAM,QAAQ,IAAI,YAAY;AAE9B,UAAM,YAAY,SAAS,YAAY;AACvC,aAAS,SAAS,aAAa,YAAa,UAAQ,CAAE;AAEtD,aAAS,gBAAgB,oFAAoF,SAAS,8CAA8C,KAAK,KAAK;AAE9K,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,gBAAgB,OAAO,aAAa,OAAO,SAAS;AAC7E,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,OAAO;AAEhC,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,KAAK,IAAI;AAErE,8BAAgB,gBAAgB,UAAU,KAAK,YAAY,GAAG,KAAK;AAEnE,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,OAAO;AAEhC,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,gBAAgB,OAAO,aAAa,OAAO,SAAS;AAC7E,aAAS,gBAAgB,gBAAgB,OAAO,YAAY,OAAO,SAAS;AAC5E,aAAS,gBAAgB,OAAO;AAEhC,aAAS,gBAAgB,UAAU;AAEnC,aAAS,SAAS,aAAa,SAAS;AAAA,EAC5C;AACJ;;;ACrFA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAgB;AAEzB,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAChD,aAAO,QAAQ;AAEf,UAAI,OAAO,uCAAkC,gBAAO,iBAAiB,GAAG;AACpE,eAAO,QAAQ;AAEf,eAAO,OAAO,IAAI,SAAQ,CAAC;AAC3B,eAAO,GAAG;AAEV,kBAAU,MAAM;AAEhB,YAAI,OAAO,uCAAkC,gBAAO,kBAAkB,GAAG;AACrE,iBAAO,IAAI;AACX,iBAAO,QAAQ;AAAA,QACnB;AAEA,eAAO;AAAA,MACX;AAAA,IAEJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAU;AACd,8BAAgB,gBAAgB,UAAU,KAAK,YAAY,CAAC;AAAA,EAChE;AACJ;;;AC9BA,IAAqB,WAArB,MAAqB,kBAAiB,KAAK;AAAA,EAEvC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,MAAM,GAAG;AACjD,aAAO,QAAQ;AAEf,UAAI,YAAY,WAAW,MAAM;AAEjC,UAAI,OAAO,uCAAkC,gBAAO,iBAAiB,GAAG;AACpE,eAAO,QAAQ;AAEf,cAAM,WAAW,IAAI,UAAS;AAE9B,YAAI,WAAW;AACX,mBAAS,aAAa,aAAa,SAAS;AAAA,QAChD;AAEA,eAAO,OAAO,QAAQ;AACtB,eAAO,GAAG;AAEV,eAAO,QAAQ,MAAM,MAAM,EAAE;AAE7B,YAAI,OAAO,uCAAkC,gBAAO,kBAAkB,GAAG;AACrE,iBAAO,IAAI;AACX,iBAAO,QAAQ;AAAA,QACnB;AAEA,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,SAAS,SAAS,SAAS,UAAU,SAAS,SAAS,IAAI,QAAQ,CAAW,IAAI,CAAC;AAEzF,UAAM,iBAAiB;AACvB,UAAM,WAAW,KAAK,YAAY,EAAE;AACpC,UAAM,YAAY,SAAS,SAAS,IAAI,WAAW,CAAW;AAC9D,UAAM,QAAQ,SAAS,SAAS,SAAS,OAAO,CAAW;AAC3D,UAAM,kBAAkB,QAAQ,SAAS,SAAS,SAAS,MAAM,CAAW,IAAI,IAAI;AACpF,UAAM,MAAM,SAAS,SAAS,SAAS,MAAM,CAAW;AACxD,UAAM,WAAW,KAAK,MAAO,YAAY,WAAY,MAAM,KAAK,MAAM,MAAM,QAAQ,CAAC;AAErF,aAAS,gBAAgB,sFAAsF,SAAS,oDAAoD;AAC5K,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,MAAM;AAE/B,aAAS,gBAAgB,eAAe;AACxC,aAAS,gBAAgB,0CAA0C;AACnE,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,cAAc;AAEvC,SAAK,YAAY,EAAE,QAAQ,CAAC,OAAO,MAAM;AAErC,eAAS,SAAS,aAAa,QAAQ;AAEvC,eAAS,gBAAgB,uCAAuC,eAAe,OAAO;AACtF,eAAS,gBAAgB,aAAa,MAAM,IAAI,CAAC,IAAI;AACrD,eAAS,gBAAgB,cAAc;AACvC,eAAS,gBAAgB,cAAc,QAAQ,gBAAgB;AAE/D,eAAS,gBAAgB,8BAA8B;AAEvD,UAAI,IAAI,WAAS,GAAG;AAChB,iBAAS,gBAAgB,kBAAkB,GAAG,gBAAgB;AAAA,MAClE;AAEA,UAAI,MAAI,GAAG;AAAA,MAEX;AAEA,eAAS,gBAAgB,GAAG;AAC5B,eAAS,gBAAgB,UAAU;AAEnC,eAAS,gBAAgB,eAAe;AACxC,eAAS,gBAAgB,qBAAqB,QAAQ,6CAA6C;AACnG,eAAS,gBAAgB,cAAc;AACvC,eAAS,gBAAgB,wBAAwB,MAAM,IAAI,CAAC,iDAAiD,GAAG,wDAAwD;AAExK,YAAM,QAAQ,QAAQ;AAEtB,eAAS,gBAAgB,QAAQ;AACjC,eAAS,gBAAgB,eAAe;AACxC,eAAS,gBAAgB,OAAO;AAChC,eAAS,gBAAgB,cAAc;AAAA,IAE3C,CAAC;AAED,aAAS,SAAS,aAAa,SAAS;AAExC,aAAS,gBAAgB,eAAe;AACxC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AACnC,aAAS,gBAAgB,cAAc;AAEvC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAAA,EACvC;AACJ;;;ACxGA,IAAqB,YAArB,MAAqB,mBAAkB,KAAK;AAAA,EAExC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,OAAO,GAAG;AAElD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,WAAU,CAAC;AAC7B,aAAO,WAAW;AAElB,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,WAAW;AACX,eAAO,aAAa,aAAa,SAAS;AAAA,MAC9C;AAEA,aAAO,aAAa;AACpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,YAAY,KAAK,aAAa,WAAW,KAAe;AAC9D,UAAM,OAAO,SAAS,SAAS,MAAM;AACrC,UAAM,QAAQ,SAAS,SAAS,OAAO;AAEvC,UAAM,MAAM,4BAAc,kBAAkB,UAAU,SAAS,WAAU;AAAA,MACrE,UAAU,GAAG,IAAI;AAAA,IACrB,CAAC;AAED,UAAM,YAAY,4BAAc,iBAAiB,GAAG;AAEpD,aAAS,gBAAgB,sFAAsF,KAAK,oDAAoD;AACxK,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,cAAc,SAAS,SAAS;AACzD,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAAA,EACvC;AACJ;;;ACrCA,IAAqB,UAArB,MAAqB,iBAAgB,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAgB;AAEzB,QAAI,OAAO,qCAAiC,KAAK,GAAG;AAEhD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,SAAQ,CAAC;AAC3B,aAAO,WAAW;AAElB,UAAI,YAAY,WAAW,MAAM;AACjC,UAAI,WAAW;AACX,eAAO,aAAa,aAAa,SAAS;AAAA,MAC9C;AAEA,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,MAAM;AAE1B,UAAI,UAAU,MAAM,MAAM,GAAG;AAEzB,YAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,gBAAM,IAAI,MAAM,wBAAwB;AAAA,QAC5C;AACA,eAAO,aAAa,KAAK;AAAA,MAC7B;AAEA,aAAO,aAAa;AAEpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,aAAa,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,MAAM,CAAmB;AACtH,UAAM,YAAY,KAAK,aAAa,WAAW;AAC/C,UAAM,MAAM,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,KAAK,CAAmB;AAE9G,UAAM,QAAQ,SAAS,IAAI,WAAW;AAEtC,QAAI,MAAM,4BAAc,kBAAkB,UAAU,OAAO,WAAW;AAAA,MAClE,oBAAoB;AAAA,MACpB,SAAS;AAAA,MACT,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,eAAe;AAAA,MACf,eAAe;AAAA,MACf,mBAAmB;AAAA,MACnB,kBAAkB;AAAA,MAClB,WAAW;AAAA,IACf,CAAC;AAED,UAAM,UAAU,IAAI,kBAAkB;AACtC,UAAM,UAAU,IAAI,SAAS;AAC7B,UAAM,eAAe,IAAI,eAAe;AAExC,UAAM,YAAY,4BAAc,iBAAiB,GAAG;AAEpD,aAAS,gBAAgB,2HAA2H;AACpJ,aAAS,gBAAgB,SAAS;AAClC,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,+BAA+B,OAAO,0DAA0D,YAAY,gCAAgC,OAAO,eAAe,OAAO,qBAAqB;AACvN,aAAS,gBAAgB,YAAY,MAAM,MAAM,GAAG,0CAA0C,SAAS,oBAAoB;AAC3H,aAAS,gBAAgB,UAAU;AACnC,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AACnC,aAAS,gBAAgB,UAAU;AAAA,EACvC;AACJ;;;ACzEe,SAAR,UAA2B,QAAgB;AAEhD,SACE,YAAY,MAAM,MAAM,KACxB,UAAU,MAAM,MAAM,KACtB,SAAS,MAAM,MAAM,KACrB,UAAU,MAAM,MAAM,KACtB,QAAQ,MAAM,MAAM,KACpB,SAAS,MAAM,MAAM,KACrB,QAAQ,MAAM,MAAM,KACpB,QAAQ,MAAM,MAAM,KACpB,QAAQ,MAAM,MAAM,EACrB;AACH;;;ACjBA,IAAqB,WAArB,MAAqB,kBAAiB,KAAK;AAAA,EAE1C,OAAO,MAAM,QAAyB;AAErC,QAAI,OAAO,qCAAiC,MAAM,GAAG;AACpD,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,UAAS,CAAC;AAC5B,aAAO,WAAW;AAElB,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AACnC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MACzC;AACA,aAAO,aAAa,SAAS;AAE7B,aAAO,aAAa;AACpB,aAAO;AAAA,IACR;AAEA,WAAO;AAAA,EACR;AAAA,EAEA,QAAQ,UAAoB;AAG3B,UAAM,UAAU,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,SAAS,CAAmB;AAEtH,aAAS,UAAU;AAAA;AAAA,kBAEH,OAAO;AAAA;AAAA,GAEtB;AAAA,EACF;AACD;;;ACjCe,SAAR,UAA2B,QAAgB;AAEjD,SACC,QAAQ,MAAM,MAAM,KACpB,UAAU,MAAM,MAAM,KACtB,YAAY,MAAM,MAAM,KACxB,SAAS,MAAM,MAAM,EACrB;AACF;;;ACXO,IAAM,UAAN,MAAc;AAAA;AAAA;AAAA;AAAA,EAKpB,OAAe,YAA6C,CAAC;AAAA;AAAA;AAAA;AAAA,EAK7D,OAAe,QAAgC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOhD,OAAO,YAAY,IAAY,UAA+B;AAC7D,QAAI,CAAE,KAAK,UAAU,EAAE,GAAG;AACzB,WAAK,UAAU,EAAE,IAAI,CAAC;AAAA,IACvB;AAEA,SAAK,UAAU,EAAE,IAAI;AAAA,MACpB,GAAG,KAAK,UAAU,EAAE;AAAA,MACpB;AAAA,IACD;AAAA,EACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,KAAK,IAAY,MAAoB;AAC3C,QAAI,CAAE,KAAK,aAAa,CAAE,KAAK,UAAU,EAAE,GAAG;AAC7C;AAAA,IACD;AAEA,SAAK,UAAU,EAAE,EAAE,QAAQ,cAAY,KAAK,MAAM,KAAK,CAAC,UAAU,IAAI,CAAC,CAAC;AACxE,SAAK,QAAQ;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,UAAgB;AACtB,QAAI,CAAE,KAAK,MAAM,QAAQ;AACxB;AAAA,IACD;AAEA,SAAK,MAAM,QAAQ,eAAa;AAC/B,YAAM,CAAC,UAAU,IAAI,IAAI;AACzB,eAAS,IAAI;AAAA,IACd,CAAC;AAGD,SAAK,QAAQ,CAAC;AAAA,EACf;AACD;;;ACtDA,IAAqB,eAArB,MAAqB,sBAAqB,KAAK;AAAA,EAE3C,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,sBAAoB,GAAG;AAE9B,aAAO,OAAO,IAAI,cAAa,OAAO,gBAAgB,CAAC,CAAC;AACxD,aAAO,QAAQ;AACf,aAAO,WAAW;AAElB,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,OAAO;AAE3B,aAAO,aAAa;AAEpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEO,kBAA0B;AAC7B,WAAO,KAAK,SAAS;AAAA,EACzB;AAAA,EAEA,QAAQ,UAAoB;AAAA,EAM5B;AACJ;;;ACnCA,IAAqB,mBAArB,MAAqB,0BAAyB,KAAK;AAAA,EAE/C,OAAO,MAAM,QAAyB;AAClC,QAAI,OAAO,qCAAgC,gBAAQ,oBAAoB,GAAG;AAEtE,aAAO,OAAO,IAAI,kBAAiB,CAAC;AACpC,aAAO,WAAW;AAElB,WAAK,mBAAmB,MAAM;AAE9B,UAAI,OAAO,qCAAgC,gBAAQ,qBAAqB,GAAG;AACvE,eAAO,aAAa;AAAA,MACxB;AAEA,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,OAAe,mBAAmB,QAAgB;AAC9C,QAAI,aAAa,MAAM,MAAM,GAAG;AAC5B,UAAI,OAAO,qCAAgC,GAAG,GAAG;AAC7C,aAAK,mBAAmB,MAAM;AAAA,MAClC;AAAA,IACJ;AAAA,EACJ;AACJ;;;AlBfA,IAAqB,cAArB,MAAqB,qBAAoB,KAAK;AAAA,EAE1C,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,gBAAQ,oBAAoB,GAAG;AACvE,aAAO,QAAQ;AACf,aAAO,OAAO,IAAI,aAAY,CAAC;AAC/B,aAAO,WAAW;AAElB,UAAI,CAAE,eAAe,MAAM,MAAM,GAAG;AAChC,cAAM,IAAI,MAAM,wBAAwB;AAAA,MAC5C;AACA,aAAO,aAAa,UAAU;AAE9B,UAAI,iBAAiB,MAAM,MAAM,GAAG;AAChC,eAAO,aAAa,cAAc;AAAA,MACtC;AAEA,aAAO,aAAa;AACpB,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,mBAAmB,KAAK,aAAa,cAAc;AACzD,QAAI,gBAAgC,CAAC;AAErC,QAAI,4BAA4B,kBAAkB;AAC9C,sBAAgB,iBAAiB,YAAY;AAAA,IACjD;AAGA,UAAM,OAAO,sCAAmB,2BAA2B,UAAU,KAAK,aAAa,UAAU,CAAmB;AAEpH,UAAM,OAAO,SAAS,IAAI,MAAM;AAChC,UAAM,WAAW,GAAG,IAAI,IAAI,IAAI;AAChC,UAAM,OAAU,gBAAa,UAAU,MAAM;AAG7C,YAAQ,mCAAyB;AAAA,MAC7B;AAAA,IACJ,CAAC;AAGD,UAAM,SAAU,IAAI,MAAM,EAAG,SAAS,IAAI;AAG1C,UAAM,SAAS,IAAI,OAAO;AAC1B,WAAO,eAAe,MAAM;AAE5B,cAAU,MAAM;AAChB,cAAU,MAAM;AAEhB,UAAM,MAAM,OAAO,OAAO;AAC1B,QAAI,UAAU,KAAK,UAAU,CAAC;AAG9B,UAAM,iBAAiB,SAAS,MAAM;AAGtC,kBAAc,QAAQ,CAAC,YAAY;AAC/B,YAAM,gBAAgB,sCAAmB,2BAA2B,UAAU,QAAQ,aAAa,OAAO,CAAmB;AAC7H,qBAAe,YAAY,QAAQ,gBAAgB,GAAG,aAAa;AAAA,IACvE,CAAC;AAGD,QAAI,KAAK,UAAU,aAAa,SAAS;AACrC,qBAAe,QAAQ,GAAG;AAAA,IAC9B,OAAO;AAEH,gCAAgB,gBAAgB,gBAAgB,IAAI,YAAY,CAAC;AAAA,IACrE;AAEA,aAAS,OAAO,cAAc;AAE9B,aAAS,UAAU,eAAe,QAAQ,CAAC;AAC3C,aAAS,MAAM,eAAe,QAAQ,CAAC;AAEvC,aAAS,oBAAoB;AAAA,EACjC;AACJ;;;AmB7FA,IAAqB,WAArB,MAAqB,kBAAiB,KAAK;AAAA,EAEvC,OAAO,MAAM,QAAyB;AAElC,QAAI,OAAO,qCAAiC,MAAM,GAAG;AACjD,aAAO,QAAQ;AAEf,UAAI,OAAO,uCAAkC,gBAAO,iBAAiB,GAAG;AACpE,eAAO,QAAQ;AAEf,eAAO,OAAO,IAAI,UAAS,CAAC;AAC5B,eAAO,GAAG;AAEV,kBAAU,MAAM;AAEhB,YAAI,OAAO,uCAAkC,gBAAO,kBAAkB,GAAG;AACrE,iBAAO,IAAI;AACX,iBAAO,QAAQ;AAAA,QACnB;AAEA,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AAExB,UAAM,UAAU,SAAS,SAAS,SAAS;AAE3C,UAAM,QAAQ,SAAS,SAAS,SAAS,OAAO,CAAW;AAC3D,UAAM,OAAO,SAAS,SAAS,SAAS,MAAM,CAAW;AACzD,UAAM,aAAa,QAAM,OAAK;AAE9B,aAAS,SAAS,aAAa,KAAK;AAEpC,QAAI,SAAS;AACT,eAAS,gBAAgB,4HAA4H;AACrJ,eAAS,gBAAgB,OAAO;AAChC,eAAS,gBAAgB,QAAQ;AAAA,IACrC;AAEA,aAAS,gBAAgB,8EAA8E;AACvG,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,wCAAwC;AAEjE,aAAS,gBAAgB,0DAA0D,UAAU,+HAA+H;AAC5N,aAAS,gBAAgB,MAAM;AAC/B,aAAS,gBAAgB,cAAc,IAAI,IAAI;AAC/C,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,yBAAyB,KAAK,OAAO;AAE9D,8BAAgB,gBAAgB,UAAU,KAAK,YAAY,CAAC;AAE5D,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,cAAc,IAAI,IAAI;AAC/C,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAEnC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,OAAO;AAChC,aAAS,gBAAgB,UAAU;AAAA,EACvC;AACJ;;;AChEA,IAAqB,UAArB,cAAqC,KAAK;AAAA,EAEtC,OAAO,MAAM,QAAyB;AAElC,WACI,QAAQ,MAAM,MAAM,KACpB,UAAU,MAAM,MAAM,KACtB,YAAY,MAAM,MAAM,KACxB,SAAS,MAAM,MAAM,EACxB;AAED,QAAI,SAAS,MAAM,MAAM,GAAG;AACxB,aAAO,QAAQ;AACf,aAAO;AAAA,IACX;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,UAAoB;AACxB,SAAK,YAAY,EAAE,QAAQ,WAAS,MAAM,QAAQ,QAAQ,CAAC;AAAA,EAC/D;AACJ;;;AC3BA,IAAqB,kBAArB,cAA6C,MAAM;AAAA,EAClD,YAAY,UAA+B,KAAY;AAEtD,QAAI,CAAE,UAAU;AACf,YAAM,oBAAoB,IAAI,IAAI,IAAI,IAAI,KAAK,aAAa,IAAI,IAAI,IAAI,IAAI,QAAQ,EAAE;AAAA,IACvF,OAAO;AACN,YAAM,8BAA8B,YAAY,SAAS,SAAS,IAAI,IAAI,IAAI,IAAI,KAAK,aAAa,IAAI,IAAI,IAAI,IAAI,QAAQ,EAAE;AAAA,IAC/H;AAEA,SAAK,OAAO;AAAA,EACb;AACD;;;ACRA,IAAqB,SAArB,MAA4B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMhB,SAAiB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAe,IAAI,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3B,QAAc,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA,EAM3B,eAAe,QAAqB;AAChC,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAA8B;AAChC,SAAK,eAAe,MAAM;AAC1B,SAAK,SAAS;AACd,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AAEP,QAAI,CAAE,KAAK,OAAO,QAAQ;AACtB;AAAA,IACJ;AAEA,QAAI,KAAK,SAAU,KAAK,OAAO,SAAO,GAAI;AACtC;AAAA,IACJ;AAEA,QAAI,QAAQ,MAAM,IAAI,GAAG;AACrB,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AACd,WAAO,KAAK,OAAO,KAAK,MAAM;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,QAAgB;AAC3B,WAAO,KAAK,OAAO,KAAK,SAAS,MAAM;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,MAAc,QAAiC,MAAM;AAC9D,QAAI,UAAU,MAAM;AAChB,cAAQ,KAAK,YAAY;AACzB,WAAK,SAAS,EAAE,gBAAgB;AAAA,IACpC;AACA,SAAK,SAAS,EAAE,aAAa,MAAM,KAAK;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AACd,WAAO,KAAK,gBAAgB,EAAE;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAQ,SAAiB,GAAG;AACxB,SAAK,SAAS,KAAK,SAAS;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,MAA0B;AAC7B,QAAI,QAAQ,KAAK,gBAAgB;AACjC,WAAQ,SAAS,MAAM,SAAS;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,MAA0B;AAC7B,QAAI,KAAK,OAAO,IAAI,GAAG;AACnB,aAAO;AAAA,IACX;AACA,UAAM,IAAI,gBAAgB,MAAM,KAAK,gBAAgB,CAAC;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,MAA0B;AAC3B,QAAI,KAAK,OAAO,IAAI,GAAG;AACnB,WAAK,QAAQ;AACb,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,MAAiB,OAAwB;AACnD,QAAI,KAAK,gBAAgB,MAAM,KAAK,GAAG;AACnC,WAAK,QAAQ;AACb,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,MAAiB,QAAyB;AAC/C,UAAM,QAAQ,KAAK,eAAe,MAAM;AACxC,WAAQ,SAAS,MAAM,SAAS;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,MAAiB,OAAwB;AACrD,UAAM,QAAQ,KAAK,gBAAgB;AACnC,WACI,SACA,MAAM,SAAS,QACf,MAAM,UAAU;AAAA,EAExB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,MAAiB,OAAwB;AAErD,QAAI,KAAK,gBAAgB,MAAM,KAAK,GAAG;AACnC,aAAO;AAAA,IACX;AAEA,UAAM,IAAI,gBAAgB,MAAM,KAAK,gBAAgB,CAAC;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,MAAiB,QAAgB,OAAwB;AACvE,QAAI,KAAK,kBAAkB,MAAM,QAAQ,KAAK,GAAG;AAC7C,aAAO;AAAA,IACX;AACA,UAAM,IAAI,gBAAgB,MAAM,KAAK,gBAAgB,CAAC;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,MAAiB,QAAgB,OAAwB;AACvE,UAAM,QAAQ,KAAK,eAAe,MAAM;AACxC,WACI,SACA,MAAM,SAAS,QACf,MAAM,UAAU;AAAA,EAExB;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK;AACD,SAAK,QAAQ,KAAK,YAAY;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM;AACF,SAAK,QAAQ,KAAK,MAAM,UAAU;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,cAAoB;AAChB,WAAO,KAAK,MAAM,YAAY,EAAE,KAAK,MAAM,YAAY,EAAE,SAAO,CAAC;AAAA,EACrE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,MAAY;AACf,SAAK,UAAU,KAAK,KAAK;AACzB,SAAK,MAAM,SAAS,IAAI;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,MAAY;AACjB,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa;AACT,SAAK,SAAS,KAAK,YAAY,CAAC;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe;AACX,SAAK,SAAS,KAAK,SAAS,EAAE,UAAU,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,KAAK,MAAY;AACb,UAAM,OAAO,KAAK,YAAY;AAC9B,SAAK,SAAS,EAAE,gBAAgB;AAEhC,SAAK,OAAO,IAAI;AAChB,SAAK,WAAW;AAEhB,SAAK,OAAO,IAAI;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,SAAkB;AACd,WAAO,KAAK;AAAA,EAChB;AACJ;;;ACvSA,IAAqB,OAArB,MAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,OAAc,KAAK,MAAc,OAAe,IAAI;AACnD,UAAM,SAAU,IAAI,MAAM,EAAG,SAAS,IAAI;AAC1C,UAAM,MAAO,IAAI,OAAO,EAAG,MAAM,MAAM;AAEvC,UAAM,UAAU,IAAI,QAAQ;AAC5B,YAAQ,sBAAsB,QAAQ,IAAI;AAE1C,WAAQ,IAAI,SAAS,OAAO,EAAG,QAAQ,GAAG;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAc,GAAG,SAAiB,UAAyB;AAC1D,YAAQ,YAAY,SAAS,QAAQ;AAAA,EACtC;AACD;","names":[]}