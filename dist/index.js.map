{"version":3,"sources":["../src/compiler/Compiler.ts","../src/grammar.ts","../src/lexer/Lexer.ts","../src/parser/Node.ts","../src/nodes/primitives/ColorPrimitiveNode.ts","../src/nodes/primitives/StringPrimitiveNode.ts","../src/nodes/primitives/VariablePrimitiveNode.ts","../src/nodes/OperatorNode.ts","../src/nodes/primitives/NumberPrimitiveNode.ts","../src/nodes/ExpressionNode.ts","../src/compiler/helpers/compile-expression-into-value.ts","../src/nodes/DefNode.ts","../src/nodes/StylePropertyNode.ts","../src/parser/helpers/parse-class.ts","../src/nodes/StyleNode.ts","../src/nodes/IncludeNode.ts","../src/nodes/ArrowNode.ts","../src/nodes/ImgNode.ts","../src/parser/helpers/compile-style-attrs.ts","../src/nodes/LineNode.ts","../src/nodes/TxtNode.ts","../src/nodes/RawNode.ts","../src/compiler/helpers/compile-with-vgap.ts","../src/nodes/GroupNode.ts","../src/nodes/ColNode.ts","../src/nodes/ColsNode.ts","../src/nodes/SpaceNode.ts","../src/nodes/BtnNode.ts","../src/parser/helpers/parse-body.ts","../src/parser/helpers/parse-head.ts","../src/events/Manager.ts","../src/nodes/BodyNode.ts","../src/parser/AstNode.ts","../src/errors/UnexpectedToken.ts","../src/parser/Parser.ts","../src/Elos.ts"],"sourcesContent":["import {AttributeValue} from \"../types/attribute\";\nimport Node from \"../parser/Node\";\n\nexport default class Compiler {\n\n    private head: string = '';\n\n    private body: string = '';\n\n    private memory: Record<string, any> = {\n        path: '',\n        variables: {\n            preview: '',\n            edge: 35,\n            hgap: 10,\n            vgap: 10,\n            bgcolor: '#ffffff',\n            width: 650\n        },\n        colsId: 0,\n        imgId: 0,\n        classes: {},\n        identStyles: {}\n    };\n\n    constructor(memory: Record<string, any> = {}) {\n        Object.assign(this.memory, memory);\n    }\n\n    getMemory(): Record<string, any> {\n        return this.memory;\n    }\n\n    setMemory(memory: Record<string, any>) {\n        this.memory = memory;\n    }\n\n    write(string: string) {\n        this.body += string;\n    }\n\n    writeLn(string: string) {\n        this.write('\\n'+string);\n    }\n\n    writeHead(string: string) {\n        this.head += string;\n    }\n\n    writeLnHead(string: string) {\n        this.writeHead('\\n'+string);\n    }\n\n    define(name: string, value: AttributeValue) {\n        this.memory.variables[name] = value;\n        return value;\n    }\n\n    variable(name: string): AttributeValue {\n        return (typeof this.memory.variables[name] === 'undefined' ? null : this.memory.variables[name]);\n    }\n\n    remember(name: string, value: AttributeValue) {\n        this.memory[name] = value;\n        return value;\n    }\n\n    get(name: string): AttributeValue {\n        return (typeof this.memory[name] === 'undefined' ? null : this.memory[name]);\n    }\n\n    getHead(): string {\n        return this.head;\n    }\n\n    getBody(): string {\n        return this.body;\n    }\n\n    clone(): Compiler {\n        return new Compiler(this.memory);\n    }\n\n    compile(ast: Node) {\n\n        ast.compile(this);\n\n        return `\n            <!doctype html>\n            <html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:v=\"urn:schemas-microsoft-com:vml\" xmlns:o=\"urn:schemas-microsoft-com:office:office\">\n                <head>\n                    <!--[if !mso]><!-->\n                    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n                    <!--<![endif]-->\n                    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n                    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                        <style type=\"text/css\">\n                          * { padding: 0; margin: 0; }\n                          #outlook a { padding:0; }\n                          body { margin:0;padding:0;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%; }\n                          table, td { border-collapse:collapse;mso-table-lspace:0pt;mso-table-rspace:0pt; }\n                          img { border:0;height:auto;line-height:100%; outline:none;text-decoration:none;-ms-interpolation-mode:bicubic; }\n                          p { display:block;margin:13px 0; }\n                        </style>\n                    ${this.getHead()}\n                </head>\n                <body bgcolor=\"${this.variable('bgcolor')}\">\n                    ${this.getBody()}\n                </body>\n            </html>\n        `;\n    }\n}\n","export default {\n\n    REGEX_IDENT: /[a-zA-ZÆÐƎƏƐƔĲŊŒẞÞǷȜæðǝəɛɣĳŋœĸſßþƿȝĄƁÇĐƊĘĦĮƘŁØƠŞȘŢȚŦŲƯY̨Ƴąɓçđɗęħįƙłøơşșţțŧųưy̨ƴÁÀÂÄǍĂĀÃÅǺĄÆǼǢƁĆĊĈČÇĎḌĐƊÐÉÈĖÊËĚĔĒĘẸƎƏƐĠĜǦĞĢƔáàâäǎăāãåǻąæǽǣɓćċĉčçďḍđɗðéèėêëěĕēęẹǝəɛġĝǧğģɣĤḤĦIÍÌİÎÏǏĬĪĨĮỊĲĴĶƘĹĻŁĽĿʼNŃN̈ŇÑŅŊÓÒÔÖǑŎŌÕŐỌØǾƠŒĥḥħıíìiîïǐĭīĩįịĳĵķƙĸĺļłľŀŉńn̈ňñņŋóòôöǒŏōõőọøǿơœŔŘŖŚŜŠŞȘṢẞŤŢṬŦÞÚÙÛÜǓŬŪŨŰŮŲỤƯẂẀŴẄǷÝỲŶŸȲỸƳŹŻŽẒŕřŗſśŝšşșṣßťţṭŧþúùûüǔŭūũűůųụưẃẁŵẅƿýỳŷÿȳỹƴźżžẓ]/,\n    REGEX_NUMBER: /\\d/,\n    REGEX_SYMBOL: /[.!?,;:()\\-+=%*\\\\/—–…${}><&#@°]/,\n    REGEX_WHITESPACE: /\\s/,\n    REGEX_NEWLINE: /[\\n\\r]/,\n    REGEX_STRING_DELIMITER: /[\"']/,\n\n    REGEX_VAR: /[a-zA-Z_-]/,\n    REGEX_VAR_START: /\\$/,\n\n    REGEX_COLOR: /[0-9a-fA-F]/,\n    REGEX_COLOR_START: /\\#/,\n\n    COMMENT_SYMBOL: '/',\n\n    BLOCK_OPEN_SYMBOL: '{',\n    BLOCK_CLOSE_SYMBOL: '}',\n\n    STRING_ESCAPE_SYMBOL: '\\\\',\n};\n","import grammar from \"../grammar\";\nimport {LexMode} from \"../types/lex-mode\";\nimport {TokenStream} from \"../types/token-stream\";\nimport {TokenType} from \"../types/token-type\";\n\nexport default class Lexer {\n\n    /**\n     * The source code to tokenize\n     * @private\n     */\n    private source: string;\n\n    /**\n     * The current mode of lexing\n     * @private\n     */\n    private mode: LexMode = LexMode.ALL;\n\n    /**\n     * The current position of the cursor\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     * The position of the cursor at the start of the mode\n     * @private\n     */\n    private modeStartCursor: number = 0;\n\n    /**\n     * The current line, starting at line 1\n     * @private\n     */\n    private line: number = 1;\n\n    /**\n     * The current position on the current line, starting at 1\n     * @private\n     */\n    private column: number = 1;\n\n    /**\n     * The current character\n     * @private\n     */\n    private character: string = '';\n\n    /**\n     * The next character, handy for simple look-ahead\n     * @private\n     */\n    private nextCharacter: string = '';\n\n    /**\n     * The index of the last character, also the amount of characters\n     * @private\n     */\n    private end: number = 0;\n\n    /**\n     * The current token stream being created\n     * @private\n     */\n    private tokens: TokenStream = [];\n\n    /**\n     * The current value being lexed\n     * @private\n     */\n    private value: string = '';\n\n    /**\n     * The current delimiter (e.g. string delimiter or boundary)\n     * @private\n     */\n    private delimiter: string = ''\n\n    /**\n     * Transforms code into a TokenStream\n     * @param text\n     */\n    tokenize(text: string): TokenStream {\n\n        this.source = text;\n        this.end = this.source.length;\n\n        while (this.cursor < this.end) {\n\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor+1] || null;\n\n            // Determine the mode\n            if (this.mode === LexMode.ALL) {\n                this.mode = this.determineMode();\n                this.modeStartCursor = this.cursor;\n            }\n\n            switch (this.mode) {\n                case LexMode.STRING:\n                    this.lexString();\n                    break;\n                case LexMode.IDENT:\n                    this.lexIdent();\n                    break;\n                case LexMode.NUMBER:\n                    this.lexNumber();\n                    break;\n                case LexMode.SYMBOL:\n                    this.lexSymbol();\n                    break;\n                case LexMode.NEWLINE:\n                    this.lexNewline();\n                    break;\n                case LexMode.WHITESPACE:\n                    this.lexWhitespace();\n                    break;\n                case LexMode.VAR:\n                    this.lexVariable();\n                    break;\n                case LexMode.COLOR:\n                    this.lexColor();\n                    break;\n                case LexMode.COMMENT:\n                    this.lexComment();\n                    break;\n                case LexMode.UNKNOWN:\n                    this.lexUnknown();\n                    break;\n            }\n        }\n\n        return this.tokens;\n    }\n\n    /**\n     * @private\n     */\n    private atEnd(accountForDelimiter: boolean = false): boolean {\n        const offset = accountForDelimiter ? 1 : 0;\n        return this.cursor + offset >= this.end;\n    }\n\n    /**\n     * Determines the lexing mode based on the current character\n     * @private\n     */\n    private determineMode(): LexMode {\n\n        // Reset the current token value\n        this.value = '';\n\n        if (\n            this.character === grammar.COMMENT_SYMBOL &&\n            this.nextCharacter === grammar.COMMENT_SYMBOL\n        ) {\n            return LexMode.COMMENT;\n        }\n\n        if (grammar.REGEX_IDENT.exec(this.character)) {\n            return LexMode.IDENT;\n        }\n\n        if (grammar.REGEX_STRING_DELIMITER.exec(this.character)) {\n            this.delimiter = this.character;\n            return LexMode.STRING;\n        }\n\n        if (grammar.REGEX_NUMBER.exec(this.character)) {\n            return LexMode.NUMBER;\n        }\n\n        if (grammar.REGEX_COLOR_START.exec(this.character)) {\n            return LexMode.COLOR;\n        }\n\n        if (grammar.REGEX_VAR_START.exec(this.character)) {\n            return LexMode.VAR;\n        }\n\n        if (grammar.REGEX_SYMBOL.exec(this.character)) {\n            return LexMode.SYMBOL;\n        }\n\n        if (grammar.REGEX_NEWLINE.exec(this.character)) {\n            return LexMode.NEWLINE;\n        }\n\n        if (grammar.REGEX_WHITESPACE.exec(this.character)) {\n            return LexMode.WHITESPACE;\n        }\n\n        return LexMode.UNKNOWN;\n    }\n\n    private lexIdent() {\n\n        this.value += this.character;\n        this.cursor++;\n\n        if (! this.nextCharacter || ! grammar.REGEX_IDENT.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.IDENT,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.value.length;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    private lexString() {\n\n        let escSequence = (this.character === grammar.STRING_ESCAPE_SYMBOL);\n\n        // String escaping\n        if (escSequence) {\n            this.cursor += 1;\n            // We directly alter the character and nextCharacter,\n            // so we can directly consume them further down in the method\n            this.character = this.source[this.cursor];\n            this.nextCharacter = this.source[this.cursor + 1] || null;\n        }\n\n        if (this.character !== this.delimiter || escSequence) {\n            // Consume the character\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (this.nextCharacter === this.delimiter) {\n            this.tokens.push({\n                type: TokenType.STRING,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(true),\n            });\n            this.cursor++;\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n            this.delimiter = '';\n        }\n    }\n\n    private lexNumber() {\n        this.value += this.character;\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_NUMBER.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.NUMBER,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.column += this.cursor - this.modeStartCursor;\n            this.mode = LexMode.ALL;\n        }\n    }\n\n    private lexSymbol() {\n\n        this.cursor++;\n\n        this.tokens.push({\n            type: TokenType.SYMBOL,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    private lexNewline() {\n        this.cursor++;\n        this.line++;\n        this.column = 1;\n        this.mode = LexMode.ALL;\n    }\n\n    private lexWhitespace() {\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    private lexColor() {\n        if (grammar.REGEX_COLOR.exec(this.character)) {\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (!this.nextCharacter || this.value.length === 6 || !grammar.REGEX_COLOR.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.COLOR,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.mode = LexMode.ALL;\n            this.column += this.cursor - this.modeStartCursor;\n            this.delimiter = '';\n        }\n    }\n\n    private lexVariable() {\n        if (grammar.REGEX_VAR.exec(this.character)) {\n            this.value += this.character;\n        }\n\n        this.cursor++;\n\n        if (!this.nextCharacter || !grammar.REGEX_VAR.exec(this.nextCharacter)) {\n            this.tokens.push({\n                type: TokenType.VAR,\n                value: this.value,\n                line: this.line,\n                position: this.column,\n                end: this.atEnd(),\n            });\n            this.mode = LexMode.ALL;\n            this.column += this.cursor - this.modeStartCursor;\n            this.delimiter = '';\n        }\n    }\n\n    private lexUnknown() {\n        this.tokens.push({\n            type: TokenType.UNKNOWN,\n            value: this.character,\n            line: this.line,\n            position: this.column,\n            end: this.atEnd(),\n        });\n        this.cursor++;\n        this.column++;\n        this.mode = LexMode.ALL;\n    }\n\n    private lexComment() {\n        this.cursor++;\n\n        if (grammar.REGEX_NEWLINE.exec(this.nextCharacter)) {\n            this.mode = LexMode.ALL;\n            this.column++;\n        }\n    }\n}\n","import {Nullable} from \"../types/nullable\";\nimport {AttributeValue} from \"../types/attribute\";\nimport Parser from \"./Parser\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"../nodes/ExpressionNode\";\n\nexport default class Node {\n\n    /**\n     *\n     * @protected\n     */\n    protected value: string;\n\n    /**\n     *\n     * @protected\n     */\n    protected parent: Nullable<Node> = null;\n\n    /**\n     *\n     * @protected\n     */\n    protected children: Node[] = [];\n\n    /**\n     *\n     * @protected\n     */\n    protected attributes: Record<string, AttributeValue> = {};\n\n    /**\n     *\n     * @param value\n     */\n    constructor(value: string = '') {\n        this.value = value;\n    }\n\n    /**\n     *\n     */\n    getName(): string {\n        return this.constructor.name;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setParent(node: Node) {\n        this.parent = node;\n    }\n\n    /**\n     *\n     */\n    getParent(): Node {\n        return this.parent;\n    }\n\n    /**\n     *\n     */\n    getValue(): string {\n        return this.value;\n    }\n\n    /**\n     *\n     * @param value\n     */\n    setValue(value: string) {\n        this.value = value;\n    }\n\n    /**\n     *\n     * @param node\n     */\n    addChild(node: Node) {\n        this.children.push(node);\n    }\n\n    /**\n     *\n     */\n    getChildren() {\n        return this.children;\n    }\n\n    /**\n     *\n     */\n    hasChildren() {\n        return (this.children.length > 0);\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: AttributeValue) {\n        this.attributes[name] = value;\n    }\n\n    /**\n     *\n     * @param name\n     */\n    getAttribute(name: string): Nullable<AttributeValue> {\n        return this.attributes[name] || null;\n    }\n\n    /**\n     *\n     */\n    getAttributes(): Record<string, AttributeValue> {\n        return this.attributes;\n    }\n\n    /**\n     *\n     */\n    removeLastChild() {\n        this.children.pop();\n    }\n\n    /**\n     *\n     * @param parser\n     */\n    parse(parser: Parser): boolean {\n        return false;\n    }\n\n    /**\n     *\n     * @param compiler\n     */\n    compile(compiler: Compiler) {\n    }\n\n    print(): string {\n\n        const printNode = (node: Node, indentAmount: number = 0): string => {\n\n            const nodeName = node.getName();\n            const nodeValue = node.getValue();\n\n            let attributes = node.getAttributes();\n            let attributesString = [];\n            for (let attribute in attributes) {\n                let attrValue = attributes[attribute];\n                if (attrValue instanceof Node) {\n                    const attrNodeValue = attrValue.getValue();\n                    attrValue = `${attrValue.getName()}${attrNodeValue ? `(${attrNodeValue})` : ''}`;\n                }\n                attributesString.push(`${attribute}=${attrValue}`);\n            }\n\n            let tabs = indentAmount > 0 ? \"   \".repeat(indentAmount - 1) + \"└──\" : \"\";\n            let output = [`${tabs}${nodeName}${nodeValue ? `(${nodeValue})` : ''} ${attributesString.join(' ')}`];\n\n            node.getChildren().forEach(childNode => {\n                output.push(printNode(childNode, indentAmount + 1));\n            });\n\n            return output.join(\"\\n\");\n        };\n\n        return printNode(this);\n    }\n}\n","import Node from \"../../parser/Node\";\nimport Parser from \"../../parser/Parser\";\nimport {TokenType} from \"../../types/token-type\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class ColorPrimitiveNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.COLOR)) {\n            parser.insert(new ColorPrimitiveNode(parser.getCurrentValue()));\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        compiler.write(`#${this.getValue()}`);\n    }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class StringPrimitiveNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.STRING)) {\n            parser.insert(new StringPrimitiveNode(parser.getCurrentValue()));\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        compiler.write(this.value);\n    }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class VariablePrimitiveNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\n\t\tif (parser.accept(TokenType.VAR)) {\n\t\t\tparser.insert(new VariablePrimitiveNode(parser.getCurrentValue()));\n\t\t\tparser.advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcompile(compiler: Compiler) {\n\t\tcompiler.write(compiler.variable(this.value) as string);\n\t}\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class OperatorNode extends Node {\n\n  static parse(parser: Parser): boolean {\n    if (parser.skipWithValue(TokenType.SYMBOL, '+')) {\n      parser.insert(new OperatorNode('+'));\n      return true;\n    }\n\n    return false;\n  }\n\n  compile(compiler: Compiler) {\n    //\n  }\n}\n","\"use strict\";\n\nimport Node from \"../../parser/Node\";\nimport {TokenType} from \"../../types/token-type\";\nimport Parser from \"../../parser/Parser\";\nimport Compiler from \"../../compiler/Compiler\";\n\nexport default class NumberPrimitiveNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\n\t\tif (parser.accept(TokenType.NUMBER)) {\n\t\t\tparser.insert(new NumberPrimitiveNode(parser.getCurrentValue()));\n\t\t\tparser.advance();\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcompile(compiler: Compiler) {\n\t\tcompiler.write(this.value);\n\t}\n}\n","import Node from \"../parser/Node\";\nimport ColorPrimitiveNode from \"./primitives/ColorPrimitiveNode\";\nimport StringPrimitiveNode from \"./primitives/StringPrimitiveNode\";\nimport Parser from \"../parser/Parser\";\nimport Compiler from \"../compiler/Compiler\";\nimport VariablePrimitiveNode from \"./primitives/VariablePrimitiveNode\";\nimport OperatorNode from \"./OperatorNode\";\nimport NumberPrimitiveNode from \"./primitives/NumberPrimitiveNode\";\n\nexport default class ExpressionNode extends Node {\n\n    static parse(parser: Parser): boolean {\n        if (\n            NumberPrimitiveNode.parse(parser) ||\n            VariablePrimitiveNode.parse(parser) ||\n            ColorPrimitiveNode.parse(parser) ||\n            StringPrimitiveNode.parse(parser)\n        ) {\n            // If we're not in an ExpressionNode yet, wrap it into one\n            if (parser.getScope().getName() !== this.name) {\n                parser.wrap(new ExpressionNode());\n            }\n\n            if (OperatorNode.parse(parser)) {\n                if (! this.parse(parser)) {\n                    throw new Error('Unexpected token '+parser.getCurrentToken().type);\n                }\n            } else {\n                // Get out of the expression\n                parser.traverseDown();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach((child, i) => {\n            child.compile(compiler);\n        });\n    }\n}\n","import Compiler from \"../Compiler\";\nimport ExpressionNode from \"../../nodes/ExpressionNode\";\nimport {Nullable} from \"../../types/nullable\";\n\nexport default {\n\tcompileExpressionIntoValue(compiler: Compiler, expression: Nullable<ExpressionNode>): Nullable<string> {\n\n\t\tif (! expression) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst compilerClone = compiler.clone();\n\t\texpression.compile(compilerClone);\n\t\treturn compilerClone.getBody();\n\t}\n};\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class DefNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'def')) {\n            parser.advance();\n\n            const defNode = new DefNode();\n\n            parser.insert(defNode);\n            parser.traverseUp();\n\n            if (parser.expect(TokenType.VAR)) {\n                defNode.setValue(parser.getCurrentValue());\n                parser.advance();\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('value');\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    public getVariableName(): string {\n        return this.getValue();\n    }\n\n    compile(compiler: Compiler) {\n        const value = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('value') as ExpressionNode);\n\n        compiler.define(this.getVariableName(), value);\n    }\n}\n","import Node from \"../parser/Node\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport StyleNode from \"./StyleNode\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class StylePropertyNode extends Node {\n\n    private property: string;\n\n    constructor(property: string, value: string) {\n        super(value);\n        this.property = property;\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.accept(TokenType.IDENT)) {\n\n            let property = parser.getCurrentValue();\n            parser.advance();\n\n            if (parser.accept(TokenType.NUMBER) || parser.accept(TokenType.STRING)) {\n                let value = parser.getCurrentValue();\n                parser.advance();\n                parser.insert(new StylePropertyNode(property, value));\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const parent = this.getParent() as StyleNode;\n        const name = parent.getValue();\n        const style = (parent.isClass ? compiler.get('classes') : compiler.get('identStyles'));\n\n        if (! style[name]) {\n            style[name] = [];\n        }\n\n        style[name] = [...style[name], [this.property, this.getValue()]];\n    }\n}\n","import {TokenType} from \"../../types/token-type\";\nimport Parser from \"../Parser\";\nimport {Nullable} from \"../../types/nullable\";\n\nexport default function parseClass(parser: Parser): Nullable<string> {\n\n    if (parser.skipWithValue(TokenType.SYMBOL, '.')) {\n        parser.expect(TokenType.IDENT);\n        let className = parser.getCurrentValue();\n        parser.advance();\n        return className;\n    }\n\n    return null;\n}\n","import Node from \"../parser/Node\";\nimport StylePropertyNode from \"./StylePropertyNode\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class StyleNode extends Node {\n\n    public isClass: boolean;\n\n    constructor(name: string, isClass: boolean) {\n        super(name);\n        this.isClass = isClass;\n    }\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.skipWithValue(TokenType.IDENT, 'style')) {\n\n            let identifier = '';\n\n            if (parser.expect(TokenType.IDENT)) {\n                identifier = parser.getCurrentValue();\n                parser.advance();\n            }\n\n            let className = parseClass(parser);\n            let isClass = (className !== null);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new StyleNode(className ? className : identifier, isClass));\n                parser.in();\n            }\n\n            while (StylePropertyNode.parse(parser));\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                parser.out();\n                parser.advance();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => child.compile(compiler));\n    }\n}\n","import * as fs from \"node:fs\";\nimport Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport parseHead from \"../parser/helpers/parse-head\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport AstNode from \"../parser/AstNode\";\nimport {Manager} from \"../events/Manager\";\nimport {EventId} from \"../types/event-id\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport Lexer from \"../lexer/Lexer\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class IncludeNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'include')) {\n            parser.advance();\n            parser.insert(new IncludeNode());\n            parser.traverseUp();\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('fileName');\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        // Compile fileName expression\n        const file = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('fileName') as ExpressionNode);\n\n        const path = compiler.get('path');\n        const filename = `${path}/${file}.elos`;\n        const code = fs.readFileSync(filename, 'utf8');\n\n        // Emit FILE_TOUCH event\n        Manager.emit(EventId.FILE_TOUCH, {\n            filename,\n        });\n\n        // Lex\n        const tokens = (new Lexer()).tokenize(code);\n\n        // Parse\n        const parser = new Parser();\n        parser.setTokenStream(tokens);\n\n        parseHead(parser);\n        parseBody(parser);\n\n        const ast = parser.getAst();\n        ast.setParent(this.getParent());\n\n        // Compile\n        const clonedCompiler = compiler.clone();\n\n        // Check if include is being used in the root (AstNode)\n        if (this.getParent() instanceof AstNode) {\n            clonedCompiler.compile(ast);\n        } else {\n            // Nope, so we compile it with vgap\n            compilerHelpers.compileWithVgap(clonedCompiler, ast.getChildren());\n        }\n\n        compiler.setMemory(clonedCompiler.getMemory());\n        compiler.writeHead(clonedCompiler.getHead());\n        compiler.write(clonedCompiler.getBody());\n    }\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\n\nexport default class ArrowNode extends Node {\n\n\tstatic parse(parser: Parser): boolean {\n\t\tif (parser.acceptWithValue(TokenType.SYMBOL, '-') && parser.expectAtWithValue(TokenType.SYMBOL, 1, '>')) {\n\t\t\tparser.advance(2);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport ArrowNode from \"./ArrowNode\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class ImgNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'img')) {\n            parser.advance();\n            parser.insert(new ImgNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('src');\n\n            if (ArrowNode.parse(parser)) {\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n    }\n\n    compile(compiler: Compiler) {\n\n        const src = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('src') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const scrollBarWidth = 15;\n        const width = parseInt(compiler.variable('width') as string);\n        const mediaQueryWidth = width + parseInt(compiler.variable('edge') as string) * 2 + scrollBarWidth;\n\n        const imgId = compiler.remember('imgId', parseInt(compiler.get('imgId') as string) + 1);\n        const currWidth = parseInt(compiler.get('currWidth') as string);\n\n        compiler.writeLnHead(`<style media=\"screen and (min-width:${mediaQueryWidth}px)\">`);\n        compiler.writeLnHead(`.elos-img-${imgId} {`);\n        compiler.writeLnHead(`width: ${currWidth}px !important;`);\n        compiler.writeLnHead('}');\n        compiler.writeLnHead('</style>');\n\n        if (url) {\n            compiler.writeLn(`<a href=\"${url}\" target=\"_blank\" style=\"text-decoration: none;\">`);\n        }\n\n        compiler.writeLn(`<img class=\"elos-img-${imgId}\" border=\"0\" src=\"${src}\" style=\"display:block; border: 0; width: 100%;\"/>`);\n\n        if (url) {\n            compiler.writeLn(`</a>`);\n        }\n    }\n}\n","import Compiler from \"../../compiler/Compiler\";\n\nconst propMap = {\n    size: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'font-size'\n    },\n    weight: {\n        type: 'string',\n        cssProperty: 'font-weight'\n    },\n    line: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'line-height'\n    },\n    height: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'height'\n    },\n    width: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'weight'\n    },\n    transform: {\n        type: 'string',\n        cssProperty: 'text-transform'\n    },\n    color: {\n        type: 'string',\n        cssProperty: 'color'\n    },\n    bgcolor: {\n        type: 'string',\n        cssProperty: 'background-color'\n    },\n    rounded: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'border-radius'\n    },\n    padding: {\n        type: 'integer',\n        unit: 'px',\n        cssProperty: 'padding'\n    },\n    align: {\n        type: 'string',\n        cssProperty: 'text-align'\n    }\n};\n\nexport default {\n    compileStyleAttrs(compiler: Compiler, ident: string, className: string = null, defaults = {}) {\n\n        const name = (className ? className : ident);\n        const styles = (className ? compiler.get('classes') : compiler.get('identStyles'));\n        const properties = styles[name] || [];\n        const css = defaults;\n\n        properties.forEach(prop => {\n\n            let cssProp = '';\n            let type = 'string';\n\n            if (propMap[prop[0]]) {\n\n                type = propMap[prop[0]]['type'];\n                cssProp = propMap[prop[0]]['cssProperty'];\n\n                switch (type) {\n                    case 'string':\n                        css[cssProp] = prop[1];\n                        break;\n                    case 'integer':\n                        const unit = (propMap[prop[0]]['unit'] ? 'px' : '');\n                        css[cssProp] = parseInt(prop[1])+unit;\n                        break;\n                }\n            }\n        });\n\n        return css;\n    },\n    attrsToCssString(cssProps) {\n        let output = '';\n\n        for (let prop in cssProps) {\n            output += `${prop}: ${cssProps[prop]};`;\n        }\n\n        return output;\n    }\n};\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class LineNode extends Node {\n\n  static parse(parser: Parser): boolean {\n    if (parser.acceptWithValue(TokenType.IDENT, \"line\")) {\n      parser.advance();\n      parser.insert(new LineNode());\n      parser.traverseUp();\n\n      let className = parseClass(parser);\n      if (className) {\n        parser.setAttribute('className', className);\n      }\n\n      parser.traverseDown();\n      return true;\n    }\n\n    return false;\n  }\n\n  compile(compiler: Compiler) {\n\n    const className = this.getAttribute('className') as string || null;\n    const width = parseInt(compiler.variable(\"width\") as string);\n\n    const css = styleCompiler.compileStyleAttrs(\n      compiler,\n      \"line\",\n      className,\n      {\n        height: \"2px\",\n        \"background-color\": \"#000000\",\n      }\n    );\n\n    const cssString = styleCompiler.attrsToCssString(css);\n\n    compiler.writeLn(\n      `<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`\n    );\n    compiler.writeLn(\"<tr>\");\n    compiler.writeLn(`<td style=\"${cssString}\"></td>`);\n    compiler.writeLn(\"</tr>\");\n    compiler.writeLn(\"</table>\");\n  }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport ArrowNode from \"./ArrowNode\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class TxtNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'txt')) {\n            parser.advance();\n            parser.insert(new TxtNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('text');\n\n            if (ArrowNode.parse(parser)) {\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const text = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('text') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const width = compiler.variable('width');\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'txt', className, {\n            'font-size': '12px',\n            'color': '#000000',\n            'line-height': '16px',\n            'text-decoration': 'none'\n        });\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLn(`<table cellspacing=\"0\" cellpadding=\"0\" style=\"max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td style=\"${cssString}\">`);\n\n        if (url) {\n            compiler.writeLn(`<a href=\"${url}\" target=\"_blank\" style=\"${cssString}\">`);\n        }\n\n        compiler.writeLn(text);\n\n        if (url) {\n            compiler.writeLn(`</a>`);\n        }\n\n        compiler.writeLn(`</td>`);\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ExpressionNode from \"./ExpressionNode\";\n\nexport default class RawNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'raw')) {\n            parser.advance();\n            parser.insert(new RawNode());\n            parser.traverseUp();\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('expression');\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        (this.getAttribute('expression') as ExpressionNode).compile(compiler);\n    }\n}\n","import Compiler from \"../Compiler\";\nimport Node from \"../../parser/Node\";\nimport RawNode from \"../../nodes/RawNode\";\nimport {AlignmentOption} from \"../../types/alignment-option\";\n\nexport default {\n    compileWithVgap(compiler: Compiler, children: Node[], align: AlignmentOption = AlignmentOption.LEFT) {\n\n        const totalChildrenCount = children.length;\n        const rawChildrenCount = children.filter(child => child instanceof RawNode).length;\n        const otherChildrenCount = totalChildrenCount - rawChildrenCount;\n\n        const hasOnlyRawChildren = otherChildrenCount === 0;\n\n        const vgap = compiler.variable('vgap');\n        const cssString = (align === AlignmentOption.CENTER ? '' : 'width: 100%;');\n\n        if (totalChildrenCount) {\n\n            if (! hasOnlyRawChildren) {\n                compiler.writeLn(`<table role=\"presentation\" style=\"${cssString}border:none;border-spacing:0;text-align:${align};font-family:Arial,sans-serif;font-size:16px;line-height:22px;color:#363636;\">`);\n            }\n\n            let otherChildIndex = 0;\n            children.forEach((child, index) => {\n\n                if (child instanceof RawNode) {\n                    child.compile(compiler);\n                } else {\n                    compiler.writeLn('<tr>');\n                    compiler.writeLn(`<td align=\"${align}\">`);\n                    child.compile(compiler);\n                    compiler.writeLn('</td>');\n                    compiler.writeLn('</tr>');\n                    if (otherChildIndex < otherChildrenCount - 1) {\n                        compiler.writeLn(`<tr><td height=\"${vgap}\"></td></tr>`);\n                    }\n\n                    otherChildIndex++;\n                }\n            });\n\n            if (! hasOnlyRawChildren) {\n                compiler.writeLn(`</table>`);\n            }\n        }\n    }\n};\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\nimport {AlignmentOption} from \"../types/alignment-option\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class GroupNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'group')) {\n            parser.advance();\n\n            let className = parseClass(parser);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                const groupNode = new GroupNode();\n\n                if (className) {\n                    groupNode.setAttribute('className', className);\n                }\n\n                parser.insert(groupNode);\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const currentWidth = compiler.get('currWidth') as string;\n        const className= this.getAttribute('className') as string || null;\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'group', className, {\n            'background-color': '#f0f0f0',\n            'padding': '25px',\n            'text-align': 'left'\n        });\n\n        const bgColor = css['background-color'];\n        const padding = parseInt(css['padding']);\n        const align = css['text-align'] as AlignmentOption;\n\n        const currWidth = parseInt(currentWidth);\n        compiler.remember('currWidth', currWidth - (padding*2));\n\n        compiler.writeLn(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width:100%;max-width:${currWidth}px;border:none;border-spacing:0;text-align:${align};\">`);\n\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" height=\"${padding}\"></td>`);\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn('</tr>');\n\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" align=\"${align}\">`);\n\n        compilerHelpers.compileWithVgap(compiler, this.getChildren(), align);\n\n        compiler.writeLn('</td>');\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn('</tr>');\n\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" height=\"${padding}\"></td>`);\n        compiler.writeLn(`<td bgcolor=\"${bgColor}\" width=\"${padding}\"></td>`);\n        compiler.writeLn('</tr>');\n\n        compiler.writeLn('</table>');\n\n        compiler.remember('currWidth', currWidth);\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport config from \"../grammar\";\nimport {TokenType} from \"../types/token-type\";\nimport Parser from \"../parser/Parser\";\n\nexport default class ColNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'col')) {\n            parser.advance();\n\n            if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new ColNode());\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n\n        }\n\n        return false;\n    }\n\n    compile(compiler) {\n        compilerHelpers.compileWithVgap(compiler, this.getChildren());\n    }\n}\n","import Node from \"../parser/Node\";\nimport ColNode from \"./ColNode\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport config from \"../grammar\";\n\nexport default class ColsNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'cols')) {\n            parser.advance();\n\n            let className = parseClass(parser);\n\n            if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                const colsNode = new ColsNode();\n\n                if (className) {\n                    colsNode.setAttribute('className', className);\n                }\n\n                parser.insert(colsNode);\n                parser.in();\n\n                while (ColNode.parse(parser));\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const colsId = compiler.remember('colsId', parseInt(compiler.get('colsId') as string) + 1);\n\n        const scrollBarWidth = 15;\n        const colCount = this.getChildren().length;\n        const currWidth = parseInt(compiler.get('currWidth') as string);\n        const width = parseInt(compiler.variable('width') as string);\n        const mediaQueryWidth = width + parseInt(compiler.variable('edge') as string) * 2 + scrollBarWidth;\n        const gap = parseInt(compiler.variable('hgap') as string);\n        const colWidth = Math.floor((currWidth / colCount) - gap + Math.floor(gap / colCount));\n\n        compiler.writeLn(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${currWidth}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLn('<tr>');\n        compiler.writeLn('<td>');\n\n        compiler.writeLn('<!--[if mso]>');\n        compiler.writeLn('<table role=\"presentation\" width=\"100%\">');\n        compiler.writeLn('<tr>');\n        compiler.writeLn('<![endif]-->');\n\n        this.getChildren().forEach((child, i) => {\n\n            compiler.remember('currWidth', colWidth);\n\n            compiler.writeLnHead(`<style media=\"screen and (min-width:${mediaQueryWidth}px)\">`);\n            compiler.writeLnHead(`.elos-col-${colsId}-${i} {`);\n            compiler.writeLnHead(`float: left;`);\n            compiler.writeLnHead(`max-width: ${colWidth}px !important;`);\n            //compiler.writeLnHead(`padding-left: ${gap/2}px;`);\n            compiler.writeLnHead(`margin-bottom: 0 !important;`);\n\n            if (i < colCount-1) {\n                compiler.writeLnHead(`padding-right: ${gap}px !important;`);\n            }\n\n            if (i===0) {\n                //compiler.writeLnHead(`margin-left: -${gap/2}px;`);\n            }\n\n            compiler.writeLnHead('}');\n            compiler.writeLnHead('</style>');\n\n            compiler.writeLn('<!--[if mso]>');\n            compiler.writeLn(`<td style=\"width: ${colWidth}px; padding: 0;\" align=\"left\" valign=\"top\">`);\n            compiler.writeLn('<![endif]-->');\n            compiler.writeLn(`<div class=\"elos-col-${colsId}-${i}\" style=\"display:inline-block; margin-bottom: ${gap}px; width:100%; vertical-align:top; text-align:left;\">`);\n\n            child.compile(compiler);\n\n            compiler.writeLn('</div>');\n            compiler.writeLn('<!--[if mso]>');\n            compiler.writeLn('</td>');\n            compiler.writeLn('<![endif]-->');\n\n        });\n\n        compiler.remember('currWidth', currWidth);\n\n        compiler.writeLn('<!--[if mso]>');\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n        compiler.writeLn('<![endif]-->');\n\n        compiler.writeLn('</td>');\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class SpaceNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'space')) {\n\n            parser.advance();\n            parser.insert(new SpaceNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            parser.traverseDown();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const className = this.getAttribute('className') as string || null;\n        const vgap = compiler.variable('vgap') as string;\n        const width = compiler.variable('width') as string;\n\n        const css = styleCompiler.compileStyleAttrs(compiler, 'space', className,{\n            'height': `${vgap}px`\n        });\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLn(`<table width=\"100%;\" cellspacing=\"0\" cellpadding=\"0\" style=\"width: 100%; max-width:${width}px;border:none;border-spacing:0;text-align:left;\">`);\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td style=\"${cssString}\"></td>`);\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n    }\n}\n","import Node from \"../parser/Node\";\nimport parseClass from \"../parser/helpers/parse-class\";\nimport styleCompiler from \"../parser/helpers/compile-style-attrs\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\nimport ArrowNode from \"./ArrowNode\";\nimport ExpressionNode from \"./ExpressionNode\";\nimport expressionCompiler from \"../compiler/helpers/compile-expression-into-value\";\n\nexport default class BtnNode extends Node {\n\n    static parse(parser: Parser) {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'btn')) {\n\n            parser.advance();\n            parser.insert(new BtnNode());\n            parser.traverseUp();\n\n            let className = parseClass(parser);\n            if (className) {\n                parser.setAttribute('className', className);\n            }\n\n            if (! ExpressionNode.parse(parser)) {\n                throw new Error('Expected an expression');\n            }\n            parser.setAttribute('text');\n\n            if (ArrowNode.parse(parser)) {\n\n                if (! ExpressionNode.parse(parser)) {\n                    throw new Error('Expected an expression');\n                }\n                parser.setAttribute('url');\n            }\n\n            parser.traverseDown();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const expression = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('text') as ExpressionNode);\n        const className = this.getAttribute('className') as string;\n        const url = expressionCompiler.compileExpressionIntoValue(compiler, this.getAttribute('url') as ExpressionNode);\n\n        const width = compiler.get('currWidth');\n\n        let css = styleCompiler.compileStyleAttrs(compiler, 'btn', className, {\n            'background-color': '#000000',\n            'color': '#ffffff',\n            'border-radius': '8px',\n            'font-size': '12px',\n            'font-weight': 'normal',\n            'line-height': '16px',\n            'text-decoration': 'none',\n            'text-transform': 'none',\n            'padding': '8px 16px'\n        });\n\n        const bgColor = css['background-color'];\n        const padding = css['padding'];\n        const borderRadius = css['border-radius'];\n\n        const cssString = styleCompiler.attrsToCssString(css);\n\n        compiler.writeLn(`<table border=\"0\" cellPadding=\"0\" cellSpacing=\"0\" role=\"presentation\" style=\"border-collapse:separate;line-height:100%;\">`);\n        compiler.writeLn('<tbody>');\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td align=\"center\" bgcolor=\"${bgColor}\" role=\"presentation\" style=\"border:none;border-radius:${borderRadius};cursor:auto;mso-padding-alt:${padding};background:${bgColor};\" valign=\"middle\">`);\n        compiler.writeLn(`<a href=\"${url ? url : '#'}\" style=\"display:inline-block;margin:0;${cssString}\" target=\"_blank\">`);\n        compiler.writeLn(expression);\n        compiler.writeLn('</a>');\n        compiler.writeLn('</td>');\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</tbody>');\n        compiler.writeLn('</table>');\n    }\n}\n","import ImgNode from \"../../nodes/ImgNode\";\nimport LineNode from \"../../nodes/LineNode\";\nimport TxtNode from \"../../nodes/TxtNode\";\nimport GroupNode from \"../../nodes/GroupNode\";\nimport ColsNode from \"../../nodes/ColsNode\";\nimport SpaceNode from \"../../nodes/SpaceNode\";\nimport BtnNode from \"../../nodes/BtnNode\";\nimport Parser from \"../Parser\";\nimport IncludeNode from \"../../nodes/IncludeNode\";\nimport RawNode from \"../../nodes/RawNode\";\n\nexport default function parseBody(parser: Parser) {\n\n  while(\n    IncludeNode.parse(parser) ||\n    SpaceNode.parse(parser) ||\n    ColsNode.parse(parser) ||\n    GroupNode.parse(parser) ||\n    ImgNode.parse(parser) ||\n    LineNode.parse(parser) ||\n    TxtNode.parse(parser) ||\n    BtnNode.parse(parser) ||\n    RawNode.parse(parser)\n  );\n}\n","import Parser from \"../Parser\";\nimport IncludeNode from \"../../nodes/IncludeNode\";\nimport DefNode from \"../../nodes/DefNode\";\nimport StyleNode from \"../../nodes/StyleNode\";\n\nexport default function parseHead(parser: Parser) {\n\n\twhile(\n\t\tDefNode.parse(parser) ||\n\t\tStyleNode.parse(parser) ||\n\t\tIncludeNode.parse(parser)\n\t);\n}\n","import {EventListener} from \"../types/event-listener\";\nimport {EventQueueTuple} from \"../types/event-queue-tuple\";\n\nexport class Manager {\n\n\t/**\n\t * @private\n\t */\n\tprivate static listeners: Record<string, EventListener[]> = {};\n\n\t/**\n\t * @private\n\t */\n\tprivate static queue: Array<EventQueueTuple> = []\n\n\t/**\n\t * Adds an event listener to the manager\n\t * @param id\n\t * @param listener\n\t */\n\tstatic addListener(id: string, listener: EventListener): void {\n\t\tif (! this.listeners[id]) {\n\t\t\tthis.listeners[id] = [];\n\t\t}\n\n\t\tthis.listeners[id] = [\n\t\t\t...this.listeners[id],\n\t\t\tlistener\n\t\t];\n\t}\n\n\t/**\n\t * Emits an event\n\t * @param id\n\t * @param data\n\t */\n\tstatic emit(id: string, data: object): void {\n\n\t\tif (! this.listeners || ! this.listeners[id]) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.listeners[id].forEach(listener => this.queue.push([listener, data]));\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Process the event queue\n\t */\n\tstatic process(): void {\n\n\t\tif (! this.queue.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.queue.forEach(queueItem => {\n\t\t\tconst [listener, data] = queueItem;\n\t\t\tlistener(data);\n\t\t});\n\n\t\t// Empty the queue\n\t\tthis.queue = [];\n\t}\n}\n","import Node from \"../parser/Node\";\nimport parseBody from \"../parser/helpers/parse-body\";\nimport compilerHelpers from \"../compiler/helpers/compile-with-vgap\";\nimport config from \"../grammar\";\nimport Parser from \"../parser/Parser\";\nimport {TokenType} from \"../types/token-type\";\nimport Compiler from \"../compiler/Compiler\";\n\nexport default class BodyNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        if (parser.acceptWithValue(TokenType.IDENT, 'body')) {\n            parser.advance();\n\n            if (parser.acceptWithValue(TokenType.SYMBOL, config.BLOCK_OPEN_SYMBOL)) {\n                parser.advance();\n\n                parser.insert(new BodyNode());\n                parser.in();\n\n                parseBody(parser);\n\n                if (parser.expectWithValue(TokenType.SYMBOL, config.BLOCK_CLOSE_SYMBOL)) {\n                    parser.out();\n                    parser.advance();\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n\n        const preview = compiler.variable('preview') as string;\n\n        const width = parseInt(compiler.variable('width') as string);\n        const edge = parseInt(compiler.variable('edge') as string);\n        const totalWidth = width+edge*2;\n\n        compiler.remember('currWidth', width);\n\n        if (preview) {\n            compiler.writeLn('<div style=\"display:none;font-size:1px;color:#ffffff;line-height:1px;max-height:0;max-width:0;opacity:0;overflow:hidden;\">');\n            compiler.writeLn(preview);\n            compiler.writeLn(`</div>`);\n        }\n\n        compiler.writeLn('<table role=\"presentation\" style=\"width:100%;border:none;border-spacing:0;\">');\n        compiler.writeLn('<tr>');\n        compiler.writeLn('<td align=\"center\" style=\"padding:0;\">');\n\n        compiler.writeLn(`<table role=\"presentation\" style=\"width:100%;max-width:${totalWidth}px;border:none;border-spacing:0;text-align:left;font-family:Arial,sans-serif;font-size:16px;line-height:22px;color:#363636;\">`);\n        compiler.writeLn('<tr>');\n        compiler.writeLn(`<td width=\"${edge}\">`);\n        compiler.writeLn('</td>');\n        compiler.writeLn(`<td style=\"max-width: ${width}px;\">`);\n\n        compilerHelpers.compileWithVgap(compiler, this.getChildren());\n\n        compiler.writeLn('</td>');\n        compiler.writeLn(`<td width=\"${edge}\">`);\n        compiler.writeLn('</td>');\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n\n        compiler.writeLn('</td>');\n        compiler.writeLn('</tr>');\n        compiler.writeLn('</table>');\n    }\n}\n","import Node from \"./Node\";\nimport Compiler from \"../compiler/Compiler\";\nimport Parser from \"./Parser\";\nimport DefNode from \"../nodes/DefNode\";\nimport StyleNode from \"../nodes/StyleNode\";\nimport IncludeNode from \"../nodes/IncludeNode\";\nimport BodyNode from \"../nodes/BodyNode\";\n\nexport default class AstNode extends Node {\n\n    static parse(parser: Parser): boolean {\n\n        while (\n            DefNode.parse(parser) ||\n            StyleNode.parse(parser) ||\n            IncludeNode.parse(parser)\n        );\n\n        if (BodyNode.parse(parser)) {\n            parser.advance();\n            return true;\n        }\n\n        return false;\n    }\n\n    compile(compiler: Compiler) {\n        this.getChildren().forEach(child => child.compile(compiler));\n    }\n}\n","import {Token} from \"../types/token\";\nimport {TokenType} from \"../types/token-type\";\nimport {Nullable} from \"../types/nullable\";\n\nexport default class UnexpectedToken extends Error {\n\tconstructor(expected: Nullable<TokenType>, got: Token) {\n\n\t\tif (! expected) {\n\t\t\tsuper(`Unexpected token ${got.type}(${got.value}) at line ${got.line},${got.position}`);\n\t\t} else {\n\t\t\tsuper(`Expected a token with type ${expected ?? 'unknown'}, got ${got.type}(${got.value}) at line ${got.line},${got.position}`);\n\t\t}\n\n\t\tthis.name = \"UnexpectedToken\";\n\t}\n}","import {TokenStream} from \"../types/token-stream\";\nimport Node from \"./Node\";\nimport AstNode from \"./AstNode\";\nimport {TokenType} from \"../types/token-type\";\nimport UnexpectedToken from \"../errors/UnexpectedToken\";\nimport {Nullable} from \"../types/nullable\";\n\nexport default class Parser {\n\n    /**\n     *\n     * @private\n     */\n    private cursor: number = 0;\n\n    /**\n     *\n     * @private\n     */\n    private tokens: TokenStream;\n\n    /**\n     *\n     * @private\n     */\n    private ast: AstNode = new AstNode();\n\n    /**\n     *\n     * @private\n     */\n    private scope: Node = this.ast;\n\n    /**\n     *\n     * @param tokens\n     */\n    setTokenStream(tokens: TokenStream) {\n        this.tokens = tokens;\n    }\n\n    /**\n     *\n     * @param tokens\n     */\n    parse(tokens: TokenStream): AstNode {\n        this.setTokenStream(tokens);\n        this.parseAll();\n        return this.ast;\n    }\n\n    /**\n     *\n     */\n    parseAll() {\n\n        if (! this.tokens.length) {\n            return;\n        }\n\n        if (this.cursor > (this.tokens.length-1)) {\n            return;\n        }\n\n        if (AstNode.parse(this)) {\n            this.parseAll();\n        }\n    }\n\n    /**\n     *\n     */\n    getCurrentToken() {\n        return this.tokens[this.cursor];\n    }\n\n    /**\n     *\n     * @param offset\n     */\n    getOffsetToken(offset: number) {\n        return this.tokens[this.cursor + offset];\n    }\n\n    /**\n     *\n     * @param name\n     * @param value\n     */\n    setAttribute(name: string, value: Nullable<string | Node> = null) {\n        if (value === null) {\n            value = this.getLastNode();\n            this.getScope().removeLastChild();\n        }\n        this.getScope().setAttribute(name, value);\n    }\n\n    /**\n     *\n     */\n    getCurrentValue() {\n        return this.getCurrentToken().value;\n    }\n\n    /**\n     *\n     * @param offset\n     */\n    advance(offset: number = 1) {\n        this.cursor = this.cursor + offset;\n    }\n\n    /**\n     *\n     * @param type\n     */\n    accept(type: TokenType): boolean {\n        let token = this.getCurrentToken();\n        return (token && token.type === type);\n    }\n\n    /**\n     *\n     * @param type\n     */\n    expect(type: TokenType): boolean {\n        if (this.accept(type)) {\n            return true;\n        }\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     */\n    skip(type: TokenType): boolean {\n        if (this.accept(type)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    skipWithValue(type: TokenType, value: string): boolean {\n        if (this.acceptWithValue(type, value)) {\n            this.advance();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     */\n    acceptAt(type: TokenType, offset: number): boolean {\n        const token = this.getOffsetToken(offset);\n        return (token && token.type === type);\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    acceptWithValue(type: TokenType, value: string): boolean {\n        const token = this.getCurrentToken();\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     *\n     * @param type\n     * @param value\n     */\n    expectWithValue(type: TokenType, value: string): boolean {\n\n        if (this.acceptWithValue(type, value)) {\n            return true;\n        }\n\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     * @param value\n     */\n    expectAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        if (this.acceptAtWithValue(type, offset, value)) {\n            return true;\n        }\n        throw new UnexpectedToken(type, this.getCurrentToken());\n    }\n\n    /**\n     *\n     * @param type\n     * @param offset\n     * @param value\n     */\n    acceptAtWithValue(type: TokenType, offset: number, value: string): boolean {\n        const token = this.getOffsetToken(offset);\n        return (\n            token &&\n            token.type === type &&\n            token.value === value\n        );\n    }\n\n    /**\n     *\n     */\n    in() {\n        this.scope = this.getLastNode();\n    }\n\n    /**\n     *\n     */\n    out() {\n        this.scope = this.scope.getParent();\n    }\n\n    /**\n     *\n     */\n    getScope(): Node {\n        return this.scope;\n    }\n\n    /**\n     *\n     */\n    getLastNode(): Node {\n        return this.scope.getChildren()[this.scope.getChildren().length-1];\n    }\n\n    /**\n     *\n     * @param node\n     */\n    insert(node: Node) {\n        node.setParent(this.scope);\n        this.scope.addChild(node);\n    }\n\n    /**\n     *\n     * @param node\n     */\n    setScope(node: Node) {\n        this.scope = node;\n    }\n\n    /**\n     *\n     */\n    traverseUp() {\n        this.setScope(this.getLastNode());\n    }\n\n    /**\n     *\n     */\n    traverseDown() {\n        this.setScope(this.getScope().getParent());\n    }\n\n    /**\n     *\n     * @param node\n     */\n    wrap(node: Node) {\n        const last = this.getLastNode();\n        this.getScope().removeLastChild();\n\n        this.insert(node);\n        this.traverseUp();\n\n        this.insert(last);\n    }\n\n    /**\n     *\n     */\n    getAst(): AstNode {\n        return this.ast;\n    }\n}\n","import Compiler from \"./compiler/Compiler\";\nimport Lexer from \"./lexer/Lexer\";\nimport Parser from \"./parser/Parser\";\nimport {EventListener} from \"./types/event-listener\";\nimport {Manager} from \"./events/Manager\";\n\nexport default class Elos {\n\n\t/**\n\t * @param code\n\t * @param path\n\t */\n\tpublic static make(code: string, path: string = '') {\n\t\tconst tokens = (new Lexer()).tokenize(code);\n\n\t\tconsole.log(tokens);\n\n\t\tconst ast = (new Parser()).parse(tokens);\n\t\treturn (new Compiler({ path })).compile(ast);\n\t}\n\n\t/**\n\t * @param eventId\n\t * @param listener\n\t */\n\tpublic static on(eventId: string, listener: EventListener) {\n\t\tManager.addListener(eventId, listener);\n\t}\n}\n"],"mappings":"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","names":[]}